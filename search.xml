<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux Shell Programming Notes</title>
    <url>/2023/02/13/Linux-Shell-Programming-Notes/</url>
    <content><![CDATA[<h1 id="Shell脚本开发"><a href="#Shell脚本开发" class="headerlink" title="Shell脚本开发"></a>Shell脚本开发</h1><p><strong>注意</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">() 和 `` 效果是一样的，在括号中执行命令，且拿到命令的执行结果</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Shell数值计算"><a href="#Shell数值计算" class="headerlink" title="Shell数值计算"></a>Shell数值计算</h1><p><strong>运算符号，Linux用于计算的命令</strong></p>
<p><img src="/../img/image-20230215144600915.png" alt="image-20230215144600915"></p>
<p><img src="/../img/image-20230215144701841.png" alt="image-20230215144701841"></p>
<h2 id="用于数值计算的命令"><a href="#用于数值计算的命令" class="headerlink" title="用于数值计算的命令"></a>用于数值计算的命令</h2><p>shell的一些基础命令，只支持整数的运算，小数的计算需要如bc这样的命令</p>
<h3 id="双小括号"><a href="#双小括号" class="headerlink" title="双小括号(())"></a>双小括号(())</h3><p><img src="/../img/image-20230215144858133.png" alt="image-20230215144858133"></p>
<h3 id="特殊符号运算"><a href="#特殊符号运算" class="headerlink" title="特殊符号运算"></a>特殊符号运算</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">++ 加一</span><br><span class="line">-- 减一</span><br><span class="line"></span><br><span class="line">++a 先计算加一，然后赋值给a</span><br><span class="line">a++ 先对a操作，再加一 </span><br></pre></td></tr></table></figure>

<p><strong>脚本开发，复杂的对用户输入判断的脚本开发</strong></p>
<ol>
<li>想好脚本的功能作用，以及需求</li>
<li>转换为Shell代码</li>
</ol>
<blockquote>
<p>开发一个接受用户输入的数字，且对运算符号判断，最终得出结果的一个计算脚本</p>
</blockquote>
<p><img src="/../img/image-20230215152657929.png" alt="image-20230215152657929"></p>
<p><img src="/../img/image-20230215153021123.png" alt="image-20230215153021123"></p>
<p><img src="/../img/image-20230215153151912.png" alt="image-20230215153151912"></p>
<p>set nu 命令查看代码行数</p>
<p>如果不想写的很复杂，就可以直接传参进去</p>
<p><img src="/../img/image-20230216171536349.png" alt="image-20230216171536349"></p>
<h3 id="let命令运算"><a href="#let命令运算" class="headerlink" title="let命令运算"></a>let命令运算</h3><p>let命令的执行效率等同于双小括号</p>
<p>但是双小括号效率更高</p>
<p><img src="/../img/image-20230216171803579.png" alt="image-20230216171803579"></p>
<h3 id="检测nginx服务是否运行的脚本"><a href="#检测nginx服务是否运行的脚本" class="headerlink" title="检测nginx服务是否运行的脚本"></a>检测nginx服务是否运行的脚本</h3><p>脚本开发的思路</p>
<ol>
<li>先想好脚本的功能，作用</li>
<li>先写伪代码</li>
</ol>
<blockquote>
<ol>
<li><p>先定义变量，用于存储些变化的值，后期用于脚本维护</p>
<p>Nginx_version&#x3D;1.7</p>
</li>
<li><p>先安装服务</p>
<p>Yum install nginx-${nginx-version}</p>
</li>
<li><p>启动服务</p>
<p>systemctl start nginx</p>
</li>
<li><p>修改配置文件</p>
</li>
<li><p>重启服务</p>
</li>
</ol>
</blockquote>
<p><img src="/../img/image-20230216173311565.png" alt="image-20230216173311565"></p>
<p><img src="/../img/image-20230216173355127.png" alt="image-20230216173355127"></p>
<h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h3><p>简单的计算器执行命令</p>
<p><em>但是存在缺陷，expr利用空格来确定参数，但是针对于一些元字符就无法辨别了，比如*</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr 5 + 3</span><br><span class="line">expr 5 \* 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出长度</span></span><br><span class="line">expr length 1234567</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑判断</span></span><br><span class="line">expr 5\&gt;6 # 输出0</span><br></pre></td></tr></table></figure>

<h4 id="expr模式匹配"><a href="#expr模式匹配" class="headerlink" title="expr模式匹配"></a>expr模式匹配</h4><blockquote>
<p>expr命令也支持模式匹配功能</p>
<p>2个特殊符号</p>
<p>：冒号，计算字符串的字符数量，Yuchao 6个字符</p>
<p>.* 任意的字符串重复0次或者多次 (指定匹配模式)</p>
<p>语法</p>
<p>expr 字符串 “:” “.*”</p>
</blockquote>
<p><img src="/../img/image-20230216174429220.png" alt="image-20230216174429220"></p>
<h4 id="expr命令判断文件名后缀是否合法"><a href="#expr命令判断文件名后缀是否合法" class="headerlink" title="expr命令判断文件名后缀是否合法"></a>expr命令判断文件名后缀是否合法</h4><p>执行脚本，传入一个文件名，然后判断该文件，是否是jpg图片文件</p>
<blockquote>
<p>思路：</p>
<p>先明白expr命令的模式匹配功能，字符串匹配上了就统计其长度，匹配不上即返回0</p>
</blockquote>
<p><img src="/../img/image-20230216175101778.png" alt="image-20230216175101778"></p>
<h3 id="bc命令"><a href="#bc命令" class="headerlink" title="bc命令"></a>bc命令</h3><blockquote>
<p>bc计算器</p>
<p>awk支持数值计算</p>
<p>中括号运算</p>
</blockquote>
<p>bc命令当作计算器来用的，命令行的计算器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式的操作，小数的计算</span></span><br><span class="line">直接输入操作</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与管道符结合计算结果</span></span><br><span class="line">echo &quot;4.2*4&quot; | bc</span><br><span class="line">result=`echo $num*4|bc`</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure>

<h4 id="bc案例"><a href="#bc案例" class="headerlink" title="bc案例"></a>bc案例</h4><p>计算出1~100的总和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方案一</span></span><br><span class="line">echo &#123;1..100&#125; | tr &quot; &quot; &quot;+&quot; | bc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方案二</span></span><br><span class="line">seq -s &quot;+&quot; 100 | bc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用双括号计算</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">((`seq -s &quot;+&quot; <span class="number">100</span>`))</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">expr</span>命令计算，<span class="built_in">expr</span>命令注意是接收多个参数来计算的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接受以空格分割的多个参数 xargs</span></span><br><span class="line">seq -s &quot; + &quot; 100 | xargs expr</span><br></pre></td></tr></table></figure>

<h3 id="awk计算"><a href="#awk计算" class="headerlink" title="awk计算"></a>awk计算</h3><p>awk也支持小数计算</p>
<p>awk支持if条件判断，数组等等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;3.2 2.2&quot; | awk &#x27;&#123;print ($1+4*$2)&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="中括号计算"><a href="#中括号计算" class="headerlink" title="中括号计算"></a>中括号计算</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">[表达式]</span></span><br><span class="line">res=$[num*4]</span><br></pre></td></tr></table></figure>

<h1 id="Shell条件判断"><a href="#Shell条件判断" class="headerlink" title="Shell条件判断"></a>Shell条件判断</h1><p><strong>read命令</strong></p>
<p>读取用户参数</p>
<blockquote>
<p>-t timeout</p>
<p>-p 提示信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -t 15 -p &quot;请输入你的名字，年龄&quot; your_name your_age</span><br></pre></td></tr></table></figure>

<h2 id="Shell条件测试"><a href="#Shell条件测试" class="headerlink" title="Shell条件测试"></a>Shell条件测试</h2><blockquote>
<p>得出真假的概念</p>
<p>shell提供条件测试的语法</p>
<p>test命令</p>
<p>[ ] 中括号</p>
</blockquote>
<p><img src="/../img/image-20230216231939933.png" alt="image-20230216231939933"></p>
<h3 id="test条件测试"><a href="#test条件测试" class="headerlink" title="test条件测试"></a>test条件测试</h3><p>test命令评估一个表达式，他的结果是真还是假，如果条件为真那么命令的执行状态码就是0，否则就不是0，通过<code>$?</code>取值</p>
<blockquote>
<p>test命令的参数</p>
<p>-e 判断该文件是否存在（文件，目录）存在就是为真就是0</p>
</blockquote>
<h4 id="test的语法参数大全"><a href="#test的语法参数大全" class="headerlink" title="test的语法参数大全"></a>test的语法参数大全</h4><p><img src="/../img/image-20230216235336694.png" alt="image-20230216235336694"></p>
<p><img src="/../img/image-20230216235655398.png" alt="image-20230216235655398"></p>
<p><img src="/../img/image-20230216235730290.png" alt="image-20230216235730290"></p>
<h4 id="test命令实践"><a href="#test命令实践" class="headerlink" title="test命令实践"></a>test命令实践</h4><p>-e 判断该文件是否存在（文件，目录）存在就是为真就是0</p>
<p>shell对于真假判断的逻辑，提供<code>&amp;&amp;,||</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">test</span> 命令</span></span><br><span class="line">test 测试参数 要测试的对象 对结果进行判断执行的逻辑动作</span><br><span class="line">-f 判断文件是否是普通文件类型（要求是存在的情况下）</span><br><span class="line">-d 判断是否是目录类型</span><br><span class="line">-z 判定字符串是否为0 若为空字符串，则为true</span><br><span class="line">-n 判定字符串是否为非0 若为空字符串，子额为false</span><br></pre></td></tr></table></figure>

<h3 id="中括号条件测试"><a href="#中括号条件测试" class="headerlink" title="中括号条件测试"></a>中括号条件测试</h3><p>脚本中经常进行</p>
<p>条件测试，用的最多都是中括号[ ]</p>
<p>test和[ ]作用是一样的</p>
<p>注意：中括号中间前后必须有空格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">注意！！！</span><br><span class="line">在条件测试中要使用变量必须添加双引号</span><br><span class="line">[ -m &quot;$filename&quot; ]</span><br><span class="line">具体用法和test一样</span><br></pre></td></tr></table></figure>

<h4 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号"></a>双中括号</h4><blockquote>
<p>[[ 条件表达式 ]]</p>
<p>验证文件是否有权限，写入权限</p>
<p>注意：不要用root，切换普通用户</p>
<p>其实用法和[] 一样</p>
</blockquote>
<h3 id="变量测试"><a href="#变量测试" class="headerlink" title="变量测试"></a>变量测试</h3><p>把字符串信息，写入到变量中</p>
<blockquote>
<p>对变量测试，必须添加双引号</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file1=&quot;yuzhang.jpg&quot;</span><br><span class="line">[ -f &quot;$file1&quot; ]&amp;&amp;echo &quot;success&quot; || echo &quot;failure&quot;</span><br></pre></td></tr></table></figure>

<p>记得参考人家写的脚本</p>
<p><code>ls /etc/init.d/</code></p>
<h3 id="字符串比较测试"><a href="#字符串比较测试" class="headerlink" title="字符串比较测试"></a>字符串比较测试</h3><p><img src="/../img/image-20230217164632985.png" alt="image-20230217164632985"></p>
<p>比较两个字符串变量的值是否相等，不等这样的情况</p>
<blockquote>
<p>&#x3D; 判断是否相等</p>
<p>!&#x3D; 判断是不等的</p>
<p>! 取结果的反义</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su_kill() &#123;</span><br><span class="line">	if test &quot;$USER&quot; = &quot;$user&quot;; then</span><br><span class="line">		kill $* &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">	else</span><br><span class="line">		su - &amp;user -s /bin/sh -c &quot;kill $*&quot; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>对于<strong>字符串变量</strong>的比较一定要记住给变量加<strong>双引号</strong></li>
<li>使用等于号判断值是否相等，左右两边也必须有<strong>空格</strong> # [ “yuzhang” &#x3D; “yuzhang” ] &amp;&amp; echo ok || echo no</li>
</ul>
<p>取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -f &quot;糖果超甜组合.txt&quot; ] &amp;&amp; echo ok || echo no</span><br><span class="line">[ ! -f &quot;糖果超甜组合.txt&quot; ] &amp;&amp; echo ok || echo no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f是希望文件是存在的，且是普通文本类型，条件符合，就为真</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">！ -f 表示对这个结果取反，【当前该文件是不存在的，因此-f结果是假的，！-f就变成真的了】</span></span><br></pre></td></tr></table></figure>

<h3 id="数值比较测试"><a href="#数值比较测试" class="headerlink" title="数值比较测试"></a>数值比较测试</h3><p><img src="/../img/image-20230220191901583.png" alt="image-20230220191901583"></p>
<ol>
<li><p>在中括号中，以及test中数值测试的用法</p>
<blockquote>
<p>在中括号中，也使用数学比较符号，但是请添加转义符号</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 1 \&gt; 2 ] &amp;&amp; echo yes || echo no</span><br><span class="line">[ 1 -gt 2 ] &amp;&amp; echo yes || echo no # 大于</span><br><span class="line">[ 1 -ge 2 ] &amp;&amp; echo yes || echo no # 大于等于</span><br><span class="line">n1=98;n2=99</span><br><span class="line">test &quot;$n1&quot; -eq &quot;$n2&quot; &amp;&amp; echo yes || echo no</span><br><span class="line">test &quot;$n1&quot; != &quot;$n2&quot; &amp;&amp; echo yes || echo no # 也支持数学符号</span><br></pre></td></tr></table></figure>

<p>在test和[]语法中，支持<code>-eq</code>此类写法，以及支持<code>&gt; &lt; = !=</code></p>
</li>
</ol>
<h4 id="双中括号-1"><a href="#双中括号-1" class="headerlink" title="双中括号"></a>双中括号</h4><p>对单中括号的补充，双中括号还支持正则处理</p>
<p>在双中括号中，不需要转移符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ 5 != 6 ]] &amp;&amp; echo yes &amp;&amp; echo no</span><br></pre></td></tr></table></figure>

<p>用的最多的是单中括号，双中括号属于特殊场景的扩展语法</p>
<p>并且 双中括号也支持<code>-eq -lt &lt; &gt; =</code></p>
<h3 id="逻辑判断符号"><a href="#逻辑判断符号" class="headerlink" title="逻辑判断符号"></a>逻辑判断符号</h3><blockquote>
<p>&amp;&amp;  -a  与运算</p>
<p>||  -o  或运算</p>
</blockquote>
<p><img src="/../img/image-20230220191813933.png" alt="image-20230220191813933"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file1=/etc/init.d/network</span><br><span class="line">file2=/etc/hostname</span><br><span class="line">[ -f &quot;$file1&quot; -a -f &quot;file2&quot; ] &amp;&amp; echo yes || echo no # 不可以使用&amp;&amp; ||</span><br><span class="line">a=&quot;&quot;</span><br><span class="line">b=&quot;yuzhang&quot;</span><br><span class="line">[[ -n &quot;$a&quot; &amp;&amp; &quot;$a&quot; = &quot;$b&quot; ]] &amp;&amp; echo yes || echo no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出no</span></span><br><span class="line">[[ -n &quot;$a&quot; &amp;&amp; ! &quot;$a&quot; = &quot;$b&quot; ]] &amp;&amp; echo yes || echo no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出<span class="built_in">yes</span></span></span><br></pre></td></tr></table></figure>

<p>参考表</p>
<p><img src="/../img/image-20230220194310244.png" alt="image-20230220194310244"></p>
<h3 id="if语句开发"><a href="#if语句开发" class="headerlink" title="if语句开发"></a>if语句开发</h3><p><strong>单分支if</strong></p>
<blockquote>
<p>if &lt;条件表达式&gt;</p>
<p>​	then</p>
<p>​		代码</p>
<p>fi</p>
<p>简化</p>
<p>if &lt;条件表达式&gt;; then</p>
<p>​	代码</p>
<p>fi</p>
</blockquote>
<p><strong>双分支if</strong></p>
<blockquote>
<p>if &lt;条件表达式&gt;</p>
<p>​	then</p>
<p>​		代码1</p>
<p>​			if &lt;条件表达式&gt;</p>
<p>​				then</p>
<p>​					代码2</p>
<p>​			fi</p>
<p>fi</p>
</blockquote>
<p><strong>if-else处理</strong></p>
<blockquote>
<p>if &lt;条件表达式&gt;</p>
<p>​	then</p>
<p>​		代码1</p>
<p>else </p>
<p>​	代码2</p>
<p>fi</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础 Notes</title>
    <url>/2023/02/11/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>学习自<a href="https://www.bilibili.com/video/BV1JY4y1v7wY/?p=1&vd_source=b13ef5c189bf6bbcf843aa22a48c4954">01 IT与互联网发展_哔哩哔哩_bilibili</a></p>
<h2 id="Linux远程连接"><a href="#Linux远程连接" class="headerlink" title="Linux远程连接"></a>Linux远程连接</h2><p>windows用户需要单独安装xshell远程连接工具，或者直接使用ssh命令，ssh命令就是提供一个远程安全的加密远程连接</p>
<p>远程连接的步骤</p>
<blockquote>
<ol>
<li><p>确保linux拥有正确配置的ip地址<br> 通过ip addr show查看linux的网络ip信息 ip：192.168.88.128&#x2F;24</p>
</li>
<li><p>安装xshell软件，进行远程连接<br> 首次安装xshell，且运行xshell软件后，会提示你建立一个会话，这个会话指的就是远程操作linux机器的终端，效果是在windows上面远程连接linux系统</p>
</li>
<li><p>使用ssh命令进行远程连接<br> &#x2F;# 解释<br> &#x2F;# ssh 是linux远程登陆的命令<br> &#x2F;# root 用户<br> &#x2F;# ssh 登陆的用户名@主机ip地址<br> ssh <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x38;&#x38;&#46;&#49;&#x32;&#x38;">&#114;&#x6f;&#111;&#116;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x38;&#x38;&#46;&#49;&#x32;&#x38;</a> &#x2F;#这个就是远程连接的命令，xshell其实也是敲打的整条命令</p>
</li>
</ol>
</blockquote>
<hr>
<span id="more"></span>

<h2 id="Linux-命令格式"><a href="#Linux-命令格式" class="headerlink" title="Linux 命令格式"></a>Linux 命令格式</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">空格</th>
<th align="center">参数</th>
<th align="center">空格</th>
<th align="center">文件，文件夹</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ls列出文件夹的内容</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">&#x2F;opt 根目录下的opt文件夹</td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center"></td>
<td align="center">-a all</td>
<td align="center"></td>
<td align="center">&#x2F;opt</td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center"></td>
<td align="center">-a</td>
<td align="center"></td>
<td align="center">如果不写 且打一个点，当前文件夹内容</td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">当前文件夹内容</td>
</tr>
</tbody></table>
<p>基本命令用法如上</p>
<ul>
<li>一般情况下，linux命令的参数可写可不写，参数意义不同</li>
<li>linux命令之间必须得有一个或者多个空格</li>
</ul>
<hr>
<h2 id="Linux-命令提示符"><a href="#Linux-命令提示符" class="headerlink" title="Linux 命令提示符"></a>Linux 命令提示符</h2><p><img src="/../img/image-20230207152652143.png" alt="image-20230207152652143"></p>
<ul>
<li>whoami 我是谁，显示当前登录的用户</li>
<li>hostname 显示当前主机名</li>
<li>pwd 显示当前的工作目录绝对路径</li>
<li>#代表超级用户的身份提示符</li>
<li>$代表普通用户的身份提示符</li>
</ul>
<h2 id="目录分割条"><a href="#目录分割条" class="headerlink" title="目录分割条"></a>目录分割条</h2><p>windows的路径分隔符是反斜杠</p>
<p>Linux目录分隔符</p>
<p><img src="/../img/image-20230207153023440.png" alt="image-20230207153023440"></p>
<p>特点：</p>
<ul>
<li>第一个斜杠代表路径的起点，根目录</li>
<li>第二个斜杠开始，就是目录之间的分隔符号 </li>
<li>linux目录结构完全是以根目录为根节点像树一样扩展开</li>
</ul>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p><img src="/../img/image-20230207154949371.png" alt="image-20230207154949371"></p>
<p>从根目录开始寻找就是绝对路径，凡是不是从根目录开始寻找就是相对路径</p>
<hr>
<h3 id="Linux重要配置文件"><a href="#Linux重要配置文件" class="headerlink" title="Linux重要配置文件"></a>Linux重要配置文件</h3><h4 id="etc重要配置文件"><a href="#etc重要配置文件" class="headerlink" title="etc重要配置文件"></a>etc重要配置文件</h4><p>打开网卡配置文件：<code>vim /etc/sysconfig/network </code></p>
<p>DNS客户端配置文件（域名解析）：<code>vim /etc/resolv.conf</code></p>
<p>主机名 ：<code>cat /etc/hostname</code></p>
<p>存储对应关系 : <code>vim /etc/hosts</code></p>
<p>开机显示信息的文件：<code>vim /etc/motd</code></p>
<p>存储机器的版本号信息：<code>cat /ect/os-release</code>(CentOS)</p>
<h4 id="x2F-proc重要路径"><a href="#x2F-proc重要路径" class="headerlink" title="&#x2F;proc重要路径"></a>&#x2F;proc重要路径</h4><p>主要存储系统硬件相关信息</p>
<h4 id="x2F-var目录下文件"><a href="#x2F-var目录下文件" class="headerlink" title="&#x2F;var目录下文件"></a>&#x2F;var目录下文件</h4><p>日志文件，可变文件的记录</p>
<hr>
<h2 id="Linux核心命令与文件管理"><a href="#Linux核心命令与文件管理" class="headerlink" title="Linux核心命令与文件管理"></a>Linux核心命令与文件管理</h2><p><strong>cd命令</strong></p>
<blockquote>
<p>change directory</p>
<p>cd 可选的参数 文件夹</p>
<p>几个特殊的目录</p>
<p>. 当前的工作目录</p>
<p>.. 上一级的工作目录</p>
<p>-上一次的工作目录</p>
<p>~ 当前系统登录的用户家目录</p>
</blockquote>
<p><strong>ls命令</strong></p>
<blockquote>
<p>list 列出文件夹中的内容</p>
<p>ls 可选参数 可选的文件夹对象</p>
<p><strong>参数用法</strong></p>
<p>-a all 显示所有的文件（包括隐藏的）</p>
<p>-l 详细的输出文件的信息</p>
<p>-h 以人类可阅读的形式输出文件大小 （搭配-l使用）</p>
<p>–full-time 以完整的时间格式输出</p>
<p>-t 根据最后修改文件时间排序文件</p>
<p>-F 在不同文件的结尾，输出不同的特殊符号</p>
<p>​	以&#x2F;结尾的就是文件夹</p>
<p>​	以*结尾的就是可执行文件</p>
<p>​	以@结尾的文件就是软连接，快捷方式</p>
<p>​	普通文件类型，结尾什么都没有</p>
<p>-d 显示文件夹本身信息，不输出其中的内容</p>
<p>-r reverse 逆转排序</p>
<p>-S 大写的s 针对文件大小进行排序，默认从大到小</p>
<p>-i 显示出文件的inode信息（文件的身份证号，存储文件的元信息，文件的大小位置权限等等）</p>
</blockquote>
<p><strong>pwd命令</strong></p>
<blockquote>
<p>print work directory 打印工作目录</p>
<p>输出当前所处的绝对路径</p>
</blockquote>
<p><strong>su命令</strong></p>
<blockquote>
<p>su 命令用户切换</p>
<p>su - 用户名 # 完全的环境变量用户切换</p>
</blockquote>
<p><strong>logout命令</strong></p>
<blockquote>
<p>退出当前登录的用户</p>
</blockquote>
<p><strong>mkdir命令</strong></p>
<blockquote>
<p>make directory 创建文件夹</p>
<p>mkdir 可选的参数 文件夹名称</p>
<p>mkdir {peiqi,cunzhang,zyz} 平行的在目录下创建三个文件夹 </p>
<p>mkdir yuzhang{1..100} bash脚本语法 一直创建yuzhang1一直到yuzhang100</p>
<p><strong>参数用法</strong></p>
<p>-p 递归创建文件夹</p>
<p>mkdir -p &#x2F;opt&#x2F;oldboy_linux&#x2F;zhuyuzhang&#x2F;111 #递归创建文件夹</p>
</blockquote>
<p><strong>touch命令</strong></p>
<blockquote>
<p>touch [选项]… 文件…</p>
<p>将每个文件的访问时间和修改时间改为当前时间</p>
<ol>
<li>创建普通文件，在linux下文件的后缀格式仅仅是一个名字而已，通过touch创建的都是普通文件</li>
<li>修改文件的时间</li>
</ol>
<p>touch {1..10} </p>
<p>touch {a..z}</p>
<p>-t 修改文件的时间 touch -t 10240606 zyz.txt</p>
</blockquote>
<p><strong>cp命令</strong></p>
<blockquote>
<ol>
<li><p>复制普通文件</p>
<p>cp命令 想复制的文件 复制之后的文件名</p>
</li>
<li><p>复制普通文件，且改名，放入到另一个文件夹中</p>
<p>cp zyz.txt .&#x2F;oldboy&#x2F; #复制放入其他文件夹，保留源文件名</p>
<p>cp zyz.txt .&#x2F;oldboy&#x2F;zyz.txt2 #复制放入其他文件夹，并改名</p>
</li>
<li><p>一次性复制多个文件,放入另一个文件夹中</p>
<p>cp zyz.exe zyz.gif .&#x2F;zyz&#x2F;</p>
</li>
<li><p>复制整个文件夹必须加上-r</p>
<p>cp -r zyz zyz2 (递归的复制文件夹)</p>
</li>
<li><p>复制且保持文件属性不变,-p参数用法</p>
<p>cp -p yuzhang.txt yuzhang.txt.2</p>
</li>
<li><p>拷贝软连接而不是源文件,保持连接属性不变 -d</p>
</li>
<li><p>-i参数的用法,覆盖文件前提示 备注: 默认系统做了alias别名功能,让我们输入cp的时候其实是cp -i参数</p>
</li>
</ol>
</blockquote>
<p><strong>mv命令</strong></p>
<blockquote>
<p>move 移动或者重命名文件</p>
<ol>
<li><p>移动文件到另一个文件夹</p>
<p>mv .&#x2F;mjj.jj .&#x2F;oldboy #把当前的mjj.jj文件 移动到 oldboy文件夹中</p>
</li>
<li><p>移动多个文件,放到另一个文件夹中</p>
<p>mv luffy* .&#x2F;oldboy&#x2F; #将当前目录所有以luffy开头的文件,文件夹移动到oldboy文件夹下</p>
</li>
<li><p>重命名的用法</p>
<p>mv 旧的文件名 新的文件名</p>
</li>
<li><p>-i 覆盖前询问</p>
<p>mv在输入的时候,系统做了别名alias,其实敲出来 mv -i</p>
</li>
<li><p>-f 强制性覆盖,不询问</p>
</li>
</ol>
</blockquote>
<p><strong>rm命令</strong></p>
<blockquote>
<ol>
<li><p>删除普通文件</p>
<p>rm yuzhang.txt #删除前会提问,是否要删除</p>
</li>
<li><p>一次性删除多个文件</p>
<p>rm yuzhang.txt.2 yuzhang.txt.3 #删除多个文件,写入多个名字,空格分隔就好</p>
</li>
<li><p>删除文件夹,必须给rm添加-r参数,默认rm只能删除文件类型</p>
<p>rm -r zyz </p>
</li>
<li><p>-d只能用于删除空文件夹</p>
<p>rm -d ilovelinux&#x2F;</p>
</li>
<li><p>强制删除文件,且不提示</p>
<p>rm -f mjj* #强制删除以mjj开头的文件,文件夹无法删除</p>
</li>
<li><p>强制删除所有文件和文件夹</p>
<p>rm -r -f .&#x2F;*</p>
</li>
<li><p>-v参数,显示删除的过程</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="Linux帮助命令"><a href="#Linux帮助命令" class="headerlink" title="Linux帮助命令"></a>Linux帮助命令</h3><p><strong>man命令</strong></p>
<p><img src="/../img/image-20230207171901691.png" alt="image-20230207171901691"></p>
<p><strong>–help命令</strong></p>
<p><img src="/../img/image-20230207172236120.png" alt="image-20230207172236120"></p>
<hr>
<h3 id="Linux命令行常用快捷键"><a href="#Linux命令行常用快捷键" class="headerlink" title="Linux命令行常用快捷键"></a>Linux命令行常用快捷键</h3><p>ctrl + c cancel当前操作</p>
<p>ctrl + l 清空屏幕内容 等于 clear</p>
<p>ctrl + d 退出当前用户</p>
<p>ctrl + a 光标移动到行首</p>
<p>ctrl + e 光标移动到行尾</p>
<p>ctrl + u 删除光标到行首的内容</p>
<hr>
<h3 id="Linux的环境变量"><a href="#Linux的环境变量" class="headerlink" title="Linux的环境变量"></a>Linux的环境变量</h3><p>echo $PATH   查看linux的环境变量</p>
<p>echo是打印的命令</p>
<p>$符号加上PATH,表示输出PATH的变量</p>
<p>PATH一定要大写,这个变量是有一堆目录组成的,分割符号是”:”,而不同于windows 的”;”</p>
<hr>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>linux平台的文本编辑器</p>
<ul>
<li>vi</li>
<li>vim</li>
</ul>
<p><img src="/../img/image-20230209141506748.png" alt="image-20230209141506748"></p>
<blockquote>
<p>vim使用流程</p>
<p>vim默认机器是不安装的，需要手动安装这个工具命令</p>
<p>yum install vim -y #通过yum软件管理工具，安装命令vim，且默认是yes</p>
<p>当vim打开不存在的文件时候，会默认创建文件</p>
<p>#语法是</p>
<ol>
<li>vim 文件名 # 打开文件</li>
<li>输入字母i，进入编辑模式，代表insert。输入字母o，在光标下一行输入</li>
<li>写完代码后，esc推出编辑模式</li>
<li>此时输入冒号，进入底线命令模式，然后输入 :wq! 强制写入文件内且退出vim，write quit ！是强制性的</li>
</ol>
</blockquote>
<h4 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h4><p>vim提供的左下上右：hjkl</p>
<blockquote>
<p>移动光标快捷键：w移动到下一个单词，b移动到上一个单词，0移动到行首，字符$移动到行尾，g移动到文章开头，G移动到文章的结尾，H移动到屏幕开头，L移动到屏幕的结尾，M移动到屏幕的中间</p>
</blockquote>
<p><strong>命令模式的查找</strong></p>
<blockquote>
<p>向下查找   &#x2F;你要查找的内容 等同于ctrl+f，按下n寻找下一个单词</p>
<p>向上查找  ?你要查找的内容 ，按下n寻找下一个单词</p>
</blockquote>
<p><strong>命令模式下的复制粘贴删除</strong></p>
<blockquote>
<p>输入yy 复制光标所在行</p>
<p>输入4yy 复制4行所在内容</p>
<p>输入p 打印复制内容，粘贴</p>
<p>输入dd 删除光标当前行</p>
<p>输入D 删除光标当前位置到行尾的内容</p>
<p>输入x 删除光标当前字符，向后删除</p>
<p>输入X 删除光标当前字符，向前删除</p>
<p>输入u 撤销上一步的操作</p>
</blockquote>
<p><strong>快捷操作</strong></p>
<blockquote>
<p>删除光标所在位置，到行尾的内容，且进入编辑模式，输入大写C</p>
<p>输入o 在当前光标下一行开始编辑</p>
<p>输入O 在光标上一行开始编辑</p>
<p>输入A 快速进入行尾，且进入编辑模式</p>
<p>输入zz 快速保存退出</p>
</blockquote>
<p><strong>批量快捷操作</strong></p>
<blockquote>
<p>快捷删除多行</p>
<ol>
<li>输入ctrl+v进入可视块模式</li>
<li>用上下左右命令选择你要操作的块</li>
<li>选中块后，输入d删除块内容</li>
</ol>
<p>快捷插入多行</p>
<ol>
<li>选中块后输入大写I，进行写代码</li>
<li>按下两次esc，自动生成多行</li>
</ol>
</blockquote>
<h4 id="vim疑难杂症"><a href="#vim疑难杂症" class="headerlink" title="vim疑难杂症"></a>vim疑难杂症</h4><p>swp文件的存在（未保存修改文件） vim -r swp文件</p>
<hr>
<h3 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>重定向的意思是，“将数据传输到其他地方”</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>输出覆盖重定向</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>输出追加重定向</td>
</tr>
<tr>
<td>&lt;或&lt;&lt;</td>
<td>标准输入重定向</td>
</tr>
</tbody></table>
<p><strong>case</strong></p>
<blockquote>
<ol>
<li><p>读取文件内容，覆盖写入到另一个文件中</p>
<p>cat douyin.txt &gt; kuaishou.txt</p>
</li>
<li><p>读取文件内容，追加写入到另一个文件中</p>
<p>cat douyin.txt &gt;&gt; kuaishou.txt</p>
</li>
<li><p>重定向写入符号</p>
<p>cat &lt; douyin.txt # 把文件中的数据发送给cat命令去读取</p>
<p>将文本内容拆分</p>
<p>xargs -n 4 &lt; shuzi.txt</p>
</li>
<li><p>重定向追加写入符</p>
<p>结合cat使用</p>
<p>cat &gt;&gt; gushi.txt &lt;&lt; EOF</p>
<p><img src="/../img/image-20230209145138278.png" alt="image-20230209145138278"></p>
</li>
</ol>
</blockquote>
<p><strong>数据流</strong></p>
<p>程序的数据流：</p>
<ul>
<li>输入流：&lt;—标准输入（stdin），键盘</li>
<li>输出流：–&gt;标准输出（stdout），显示器，终端</li>
<li>错误输出流：–&gt;错误输出（stderr），一般来说包括命令找不到等错误输出到终端</li>
</ul>
<p><strong>文件描述符</strong></p>
<p>在Linux系统中，一切设备都看作文件</p>
<p>而没打开一个文件，就有一个代表该打开文件的文件描述符。</p>
<p>程序启动时默认打开三个I&#x2F;O设备文件：</p>
<ul>
<li>标准输入文件stdin，文件描述符0</li>
<li>标准输出文件stdout，文件描述符1</li>
<li>标准错误输出文件stderr，文件描述符2</li>
</ul>
<p><img src="/../img/image-20230211163018573.png" alt="image-20230211163018573"></p>
<p><strong>特殊重定向，合并重定向</strong></p>
<ul>
<li><code>2&gt;&amp;1</code>把标准错误，重定向到标准输出</li>
</ul>
<p>把命令执行的结果写入文件，标准错误当作标准输出处理，也写入文件</p>
<ul>
<li>Command &gt; &#x2F;path&#x2F;file 2&gt;&amp;1</li>
</ul>
<p>命令都会有正确的输出和错误的输出</p>
<p>ls &#x2F;tmp &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 #把命令的正确，或者错误结果都写入&#x2F;dev&#x2F;null黑洞文件中里面</p>
<hr>
<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p><strong>case</strong></p>
<blockquote>
<ol>
<li><p>查看文本内容以及功能参数</p>
<p>cat 文件名 # 直接读取文件内容</p>
</li>
<li><p>对非空行显示行号</p>
<p>cat -b gushi.txt</p>
</li>
<li><p>对所有行显示行号</p>
<p>cat -n gushi.txt</p>
</li>
<li><p>在每行结尾加上$</p>
<p>cat -n -E gushi.txt</p>
</li>
<li><p>减少空行数量，多个空行变为一个</p>
<p>cat -s -n gushi.txt</p>
</li>
</ol>
</blockquote>
<p><strong>cat命令合并多个文件</strong></p>
<blockquote>
<p>合并多个文件内容，写入到新的文件中</p>
<p>cat douyin.txt gushi.txt &gt; .&#x2F;together.txt</p>
</blockquote>
<p><strong>cat非交互式的写入文件内容</strong></p>
<blockquote>
<p>cat &gt;&gt; yuzhang.txt &lt;&lt;EOF</p>
<p>&gt; 我是zyz</p>
<p>&gt; 再见</p>
<p>&gt; EOF</p>
</blockquote>
<p><strong>cat清空文件用法</strong></p>
<blockquote>
<ol>
<li><p>直接清空文件，留下了一个空行</p>
<p>echo &gt; gushi.txt</p>
</li>
<li><p>直接清空，不留痕迹</p>
<p>&gt; gushi.txt</p>
</li>
<li><p>利用cat读取黑洞文件，然后清空</p>
<p>&#x2F;dev&#x2F;null</p>
<p>cat &#x2F;dev&#x2F;null &gt; douyin.txt</p>
</li>
</ol>
</blockquote>
<hr>
<h4 id="其他读取文件内容的命令"><a href="#其他读取文件内容的命令" class="headerlink" title="其他读取文件内容的命令"></a>其他读取文件内容的命令</h4><p><strong>tac命令</strong></p>
<p>与cat命令相反，倒着查看文件内容</p>
<p><strong>grep命令</strong></p>
<p>过滤字符串信息的命令</p>
<p><strong>管道符|</strong></p>
<p><img src="/../img/image-20230209155010707.png" alt="image-20230209155010707"></p>
<blockquote>
<ol>
<li><p>对字符串进行二次过滤</p>
<p>cat gushi.txt | grep “know me”</p>
<p>查看gushi.txt文本的内容，且对内容进行二次过滤，找出有关know me的行</p>
<p>grep命令：过滤</p>
</li>
</ol>
</blockquote>
<p><strong>more less命令</strong></p>
<p>分屏查看文件内容</p>
<blockquote>
<p>more 文件名 #分屏显示文件内容</p>
<p>按下enter显示下一行</p>
<p>空格向下滚动一个屏幕大小</p>
<p>&#x3D;显示当前行好</p>
<p>q退出more</p>
</blockquote>
<p><strong>head和tail命令</strong></p>
<p>head命令用于查看文件开头的n行</p>
<blockquote>
<p>head -5 douyin.txt</p>
<p>head douyin.txt #默认显示十行</p>
<p>head -c 5 文件名 #输出这个文件中的五个字符</p>
</blockquote>
<p>tail命令用于查看你文件结尾的n行</p>
<blockquote>
<p><em>同于head</em></p>
<p>-f 实时刷新文件内容变化</p>
<p>tail -f gushi.txt # 监测日志</p>
<p>-F 不断地打开文件，一般和-f结合使用</p>
</blockquote>
<hr>
<h3 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h3><blockquote>
<ol>
<li><p>截取每一行的第四个字符</p>
<p>cut -c 4 alex.txt</p>
</li>
<li><p>截取每一行的第四到第六个字符</p>
<p>cut -c 4-6 alex.txt</p>
</li>
<li><p>截取每一行的第五个和第七个字符</p>
<p>cut -c 5,7 alex.txt</p>
</li>
<li><p>截取一个范围的字符，第四个到结尾</p>
<p>cut -c 4- alex.txt</p>
</li>
<li><p>截取一个范围的字符，开头到第六个字符</p>
<p>cut -c -6 alex.txt</p>
</li>
<li><p>指定分隔符号，进行截取</p>
<p>cut -d “:” -f 区域范围 alex.txt</p>
<p>找出第一个到第三个区域的内容</p>
<p>cut -d “:” -f 1-3 alex.txt</p>
</li>
<li><p>可以联合管道符|输出内容</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h3><blockquote>
<ol>
<li><p>对文件第一个字符排序 默认从小到大</p>
<p>sort -n file.txt</p>
</li>
<li><p>堆排序结果反转，从大到小排序</p>
<p>sort -n -r file.txt</p>
</li>
<li><p>对排序结果去重排序</p>
<p>sort -u file.txt</p>
</li>
<li><p>指定分隔符号,指定区域 进行排序(要用-n从小到大排序)</p>
<p>sort -n -t “.” -k 4 ip.txt</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="uniq命令"><a href="#uniq命令" class="headerlink" title="uniq命令"></a>uniq命令</h3><p>uniq命令可以输出或者忽略文件中的重复行，常与sort排序相结合使用</p>
<blockquote>
<ol>
<li><p>去除连续的重复行</p>
<p>uniq luffy.txt</p>
</li>
<li><p>结合sort使用，去重更精准</p>
<p>sort -n lufft.txt | uniq</p>
</li>
<li><p>统计每一行重复次数</p>
<p>sort -n lufft.txt | uniq -c</p>
</li>
<li><p>只找出文件中重复行，不找出只出现一次的行</p>
<p>sort -n lufft.txt | uniq -c -d</p>
</li>
<li><p>只找到出现过一次的</p>
<p>sort -n lufft.txt | uniq -c -u</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><p>wc命令用于统计文件的行数，单词，字节数</p>
<blockquote>
<ol>
<li><p>统计文件的行数</p>
<p>wc -l luffy.txt</p>
</li>
<li><p>统计单词的的数量</p>
<p>echo “alex mjj cunzhang yuzhang” | wc -w</p>
</li>
<li><p>打印字符数量</p>
<p>echo “chaoge” | wc -m</p>
<p>7</p>
<p>因为字符串结尾有一个$符号</p>
<p>echo “chaoge” | cat -E #进行验证</p>
</li>
<li><p>打印最长行的字符数量</p>
<p>cat alex.txt | wc -L</p>
</li>
<li><p>联合w who命令联合使用</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h3><p>tr命令从标准输入中替换，缩减 或者删除字符，将结果写入到标准输出</p>
<blockquote>
<ol>
<li><p>替换标准输入中的大小写</p>
<p>echo “my name is yuzhang” | tr ‘[a-z]’ ‘[A-Z]’</p>
</li>
<li><p>使用-d删除操作</p>
<p>echo “my name is yuzhang 9999” | tr -d ‘[a-z]’ </p>
<p>echo “my name is yuzhang 9999” | tr -d ‘[0-9]’ </p>
</li>
<li><p>使用重定向符号，那文件当作标准输入，进行字符替换</p>
<p>tr ‘a’ ‘A’ &lt; alex.txt</p>
<p>my nAme is Alex.</p>
<p>i like leArning python And linux.</p>
</li>
<li><p>删除多个连续重复字符 -s</p>
<p>echo “iiiiii am aaaalllllexxxx” | tr -s ‘iaxl’</p>
<p>i am alex</p>
</li>
</ol>
</blockquote>
<h3 id="linux文件搜索"><a href="#linux文件搜索" class="headerlink" title="linux文件搜索"></a>linux文件搜索</h3><p><strong>stat命令</strong></p>
<p>用于显示文件的状态信息，stat命令比ls命令输出信息更加详细。</p>
<p><img src="/../img/image-20230210135849204.png" alt="image-20230210135849204"></p>
<p><strong>find命令</strong></p>
<p>用于在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。</p>
<blockquote>
<ol>
<li><p>根据名字 进行全盘搜索</p>
<p>find 从哪儿找 名字是什么</p>
<p>find &#x2F; -maxdepth 1 -name “*.txt”  #maxdepth代表只往下搜索一层</p>
<p>-type f 普通文件类型查找 d 目录类型查找</p>
<p>-delete 删除动作，找到文件后删除动作</p>
</li>
<li><p>根据时间进行搜索</p>
<p>find . -atime -2 # -2表示两天以内访问过的文件 2表示恰好在两天以前访问的文件 +2超过两天的访问时间</p>
</li>
<li><p>find 反向查找</p>
<p>find . -maxdepth 1 -type d #找到当前目录下所有文件夹</p>
<p>find . -maxdepth 1 ! -type d #找到当前目录下所有非文件夹类型的文件 ！取反</p>
</li>
<li><p>find 根据文件夹大小搜索</p>
<p>find . -maxtype 2 -type f -size +200M</p>
</li>
<li><p>find 指定忽略目录进行查找</p>
<p>find . -path “.&#x2F;test_find” -prune -o -name “*.txt” -print</p>
<p>-path “.&#x2F;test_find” -prune是忽略文件夹搜索</p>
<p>-o -name “*.txt” -print是进行合并输出</p>
</li>
<li><p>find -ok命令找到文件后继续处理</p>
<p>find . -type f -name “*.txt” -ok rm {} ;</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="xargs命令"><a href="#xargs命令" class="headerlink" title="xargs命令"></a>xargs命令</h3><p>把其他命令的参数丢给另一个命令 管道命令</p>
<blockquote>
<ol>
<li><p>多行变为单行</p>
<p>xargs &lt; chaoge.txt</p>
<p>xargs -n 2 &lt; chaoge.txt</p>
<p>-d 指定分隔符号 默认为空格</p>
<p>echo “alex,mjj,cunzhang,yuzhang” | xargs -d “,” # 去除逗号 产生分割</p>
</li>
<li><p>-i {}替代传输的数据</p>
<p>将所有txt文件，移动到alltmptxt目录中</p>
<p>find . -name “*.txt”  | xargs -i mv {} alltmptxt&#x2F;</p>
<p>找到所有txt文件 传输给xargs -i说明用{}对所有文件替代，然后再move里面使用{}</p>
</li>
<li><p>-I 用字符串替换数据</p>
<p>find . -name “*.txt” | xargs -I alltxt mv alltxt .&#x2F;</p>
<p>找到所有txt文件 传输给xargs -I说明利用alltxt字符串替换这些文件，然后移动到当前文件夹下</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="文件属性管理"><a href="#文件属性管理" class="headerlink" title="文件属性管理"></a>文件属性管理</h3><p><img src="/../img/image-20230210143651776.png" alt="image-20230210143651776"></p>
<p><strong>文件类型</strong></p>
<p>linux的文件名只是为了方便阅读，对文件属性权限没有任何影响。</p>
<p><img src="/../img/image-20230210143904482.png" alt="image-20230210143904482"></p>
<p>通过touch，cp，echo，&gt;等命令都是生成普通文件——‘-‘</p>
<p><em>普通文件</em></p>
<p>特征就是以’-‘开头，以内容一起办区分为</p>
<ul>
<li>纯文本，可以用cat命令进行读取，类似于字符，数字等</li>
<li>二进制文件（binary），linux中命令属于这种格式</li>
</ul>
<p><em>文件夹</em></p>
<p>以’d’开头 是一种特殊的文件</p>
<p><em>软连接类型</em></p>
<p>以’l’开头</p>
<p><strong>file命令</strong></p>
<p>查看具体文件具体类型</p>
<p><strong>which命令</strong></p>
<p>查找路径所在（环境变量）</p>
<hr>
<h3 id="打包压缩解压缩命令"><a href="#打包压缩解压缩命令" class="headerlink" title="打包压缩解压缩命令"></a>打包压缩解压缩命令</h3><p><strong>tar命令</strong></p>
<blockquote>
<p>tar 语法格式</p>
<p>tar 参数 你要压缩后的文件名 你要压缩什么内容</p>
<ol>
<li><p>对tmp下所有内容打包，生成alltmp.tar</p>
<p>tar -cvf alltmp.tar .&#x2F;* #将所有文件打包并列出对应步骤</p>
<p>此操作只是将文件打包并没有压缩</p>
</li>
<li><p>拆开备份文件，拆开快递</p>
<p>tar -xvf ..&#x2F;alltmp.tar .&#x2F;</p>
</li>
<li><p>对tmp下所有文件，进行打包且压缩，节省磁盘空间</p>
<p>tar -czvf alltmp.tar.gz .&#x2F;*</p>
</li>
<li><p>解压缩操作</p>
<p>tar -xzvf ..&#x2F;alltmp.tar.gz .&#x2F;</p>
</li>
<li><p>-t参数列出压缩文件中都有哪些内容</p>
<p>tar -ztvf alltmp.tar.gz</p>
</li>
<li><p>单独的取出压缩文件中的内容</p>
<p>tar -zxvf a alltmp.tar.gz .&#x2F;yuzhang.txt #将压缩包中的yuzhang.txt解压缩提出</p>
</li>
<li><p>指定目录解压缩</p>
<p>tar -zxvf alltmp.tar.gz -C .&#x2F;alltmp&#x2F;</p>
</li>
<li><p>排除文件解压缩</p>
<p>tar -zxvf .&#x2F;alltmp.tar.gz –exclude alex.txt</p>
</li>
<li><p>tar命令压缩快捷方式的源文件，而不是压缩快捷方式</p>
<p>tar -zchf kx2.tar.gz .&#x2F;kx.txt #-h参数说明压缩源文件而不是压缩快捷方式</p>
</li>
</ol>
</blockquote>
<p><img src="/../img/image-20230210151426480.png" alt="image-20230210151426480"></p>
<p><strong>gzip命令</strong></p>
<p>tar命令相当于用纸箱子打包，gzip命令相当于压缩机器</p>
<blockquote>
<ol>
<li><p>对当前所有的txt文件进行压缩 </p>
<p>gzip .&#x2F;*.txt</p>
<p>gzip无法压缩文件夹，需要tar对文件夹打包后，才能用gzip压缩</p>
</li>
<li><p>列出压缩内容 -l参数</p>
</li>
</ol>
</blockquote>
<p><strong>zip命令</strong></p>
<blockquote>
<p>zip alltmp.zip .&#x2F;* #压缩当前目录下所有的文件到alltmp.zip</p>
<p>unzip alltmp.zip #解压缩</p>
</blockquote>
<hr>
<h2 id="Linux的用户管理"><a href="#Linux的用户管理" class="headerlink" title="Linux的用户管理"></a>Linux的用户管理</h2><p>Linux系统不同用户权限不一样：</p>
<ul>
<li>root用户：唯一，权力最大，可以操作任意命令</li>
<li>普通用户：权力较低，只能在自己家目录做事，权限不足需要由root创建</li>
<li>虚拟用户：假用户，没有登陆系统的功能，系统运行依赖于用户，如bin，ftp，mail，由系统创建</li>
</ul>
<p><strong>“组”是具有相似权限的多个用户的集合</strong></p>
<p>root用户所在的组成为root组。</p>
<p><em>root为什么叫做root？</em></p>
<blockquote>
<p>在Linux系统中引入了uid和gid的概念</p>
<p>uid：user identify 相当于身份证号，gid：group identify 相当于部门编号</p>
<p>当uid为0时，Linux系统的超级用户，称之为root，gid也为0</p>
<p>普通用户是由root创建，uid号码从1000开始，向后递增</p>
<p>系统中的虚拟用户，uid是1~999之间，由操作系统创建</p>
</blockquote>
<p><strong>用户组group</strong></p>
<p>把多个用户加入到同一个组中，从而方便为族中的用户统一规划权限或者指定任务。</p>
<p><strong>用户和组的关系</strong></p>
<ul>
<li>一对一，一个用户可以存在一个租里，组里就一个成员</li>
<li>一对多，一个用户呆在多个组里</li>
<li>多对一，多个用户在一个组里，这些用户和组具有相同的权限</li>
<li>多对多，多个用户存在多个组里</li>
</ul>
<p><strong>常用命令解释器</strong></p>
<blockquote>
<p>shell解释器，解释的过程</p>
<p>echo “hello world” 是通过解释器，进行翻译，再传达给操作系统</p>
<p>包括以下：</p>
<p>&#x2F;bin&#x2F;sh 默认</p>
<p>&#x2F;bin&#x2F;bash 默认</p>
<p>&#x2F;sbin&#x2F;nologin 虚拟用户</p>
<p>&#x2F;dash ubuntu</p>
<p>csh unix</p>
<p>tsh unix</p>
</blockquote>
<p><strong>用户信息配置文件</strong></p>
<p>&#x2F;etc&#x2F;passwd文件内容</p>
<p><img src="/../img/image-20230210214907154.png" alt="image-20230210214907154"></p>
<p>新创建的用户信息会追加到这个文件结尾</p>
<p>useradd 用户名 #创建普通用户的同时，会创建一样的用户组</p>
<p>用户指定了&#x2F;bin&#x2F;bash解释器，代表可以登录机器，进行命令翻译</p>
<p>&#x2F;sbin&#x2F;nologin 禁止登录机器</p>
<p>&#x2F;etc&#x2F;shadow 存放用户加密后的密码</p>
<hr>
<p><strong>用户管理的命令</strong></p>
<p><strong>useradd命令</strong> </p>
<p>useradd yuzhang # 默认&#x2F;etc&#x2F;passwd，生成用户家目录&#x2F;home&#x2F;yuzhang</p>
<p>切换到&#x2F;home&#x2F;yuchao下 -a浏览所有文件，其中包括</p>
<p>. .. .bash_logout .bash_profile .bashrc</p>
<p>.bash_profile 用户个人的配置文件</p>
<p>useradd 用户名 #创建新用户</p>
<p>passwd 用户名 #更改密码</p>
<p><img src="/../img/image-20230210223713579.png" alt="image-20230210223713579"></p>
<hr>
<h3 id="创建用户的流程"><a href="#创建用户的流程" class="headerlink" title="创建用户的流程"></a>创建用户的流程</h3><ol>
<li>useradd yuzhang</li>
<li>系统读取&#x2F;etc&#x2F;login.defs(用户定义文件)，和&#x2F;etc&#x2F;default&#x2F;useradd（用户默认配置文件）俩文件中定义的规则创建用户</li>
<li>向&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;group文件中添加用户和组信息，向&#x2F;etc&#x2F;shadow和&#x2F;etc&#x2F;gshadow中添加密码信息</li>
<li>根据&#x2F;etc&#x2F;default&#x2F;useradd文件中配置的信息创建用户家目录</li>
<li>把&#x2F;etc&#x2F;skel中所有的文件复制到新用户家目录中</li>
</ol>
<p><img src="/../img/image-20230210225858111.png" alt="image-20230210225858111"></p>
<p><strong>创建用户有关的目录&#x2F;etc&#x2F;skel</strong></p>
<p>此目录存放新用户所需要的基础环境变量文件，添加新用户的时候，这个目录下所有文件自动被复制到新家目录下，且默认是隐藏文件，以点开头。</p>
<p><img src="/../img/image-20230210230302776.png" alt="image-20230210230302776"></p>
<p><strong>usermod命令</strong></p>
<p>usermod命令用于修改系统已存在的用户信息，只能修改未使用中的用户</p>
<p>例如：-u 修改uid -s修改用户登录后使用的shell -c修改注释 -G修改用户所属附加组 -d修改用户登陆时的目录</p>
<p><strong>userdel命令</strong></p>
<p>删除用户与相关文件</p>
<ul>
<li>建议注释掉而不是删除</li>
</ul>
<p><strong>批量更新密码命令</strong></p>
<blockquote>
<ol>
<li><p>查看当前机器的用户信息</p>
<p>tail &#x2F;etc&#x2F;passwd</p>
</li>
<li><p>批量修改密码，ctrl+d结束输入</p>
<p>chpasswd</p>
<p>yu:123</p>
<p>py:456</p>
<p>testyu:789</p>
</li>
</ol>
</blockquote>
<p><strong>用户查询命令</strong></p>
<p>whoami命令显示可用于查看的当前登录的用户，我是谁</p>
<p>w命令显示当前已登陆的用户</p>
<p>who命令显示更全面的w命令的信息</p>
<p>last，lastlog命令查看用户详细的登录信息</p>
<hr>
<h3 id="Linux用户身份切换命令"><a href="#Linux用户身份切换命令" class="headerlink" title="Linux用户身份切换命令"></a>Linux用户身份切换命令</h3><p><strong>su命令</strong></p>
<p>su命令用于切换到指定用户</p>
<p><em>root切换普通用户不需要密码</em></p>
<blockquote>
<p>第一种：su 用户</p>
<p>不推荐使用，因为是直接切换，没有完全切换环境变量</p>
<p><img src="/../img/image-20230211121241248.png" alt="image-20230211121241248"></p>
<p>第二种：su - 用户</p>
<p>标准切换，会完全切换环境变量</p>
<p><img src="/../img/image-20230211121258437.png" alt="image-20230211121258437"></p>
</blockquote>
<p><strong>sudo命令</strong></p>
<p>sudo命令用来以其他的身份来执行命令，预设的身份为root。在&#x2F;etc&#x2F;sudoers中设置了可执行sudo命令的用户。</p>
<p>普通用户不需要root密码即可用root权限执行命令。</p>
<p>使用sudo命令，以root身份执行命令，提权命令</p>
<p>visudo修改&#x2F;etc&#x2F;sudoers文件内容，如果用户权限不够，就先修改文件内容添加权限，然后用sudo命令</p>
<p><img src="/../img/image-20230211121944536.png" alt="image-20230211121944536"></p>
<hr>
<h3 id="Linux的文件权限"><a href="#Linux的文件权限" class="headerlink" title="Linux的文件权限"></a>Linux的文件权限</h3><p>属主，这个文件属于谁</p>
<p>属组，这个文件属于哪个组</p>
<p>利用ls -l查看文件具体信息 等同于 ll</p>
<p><img src="/../img/image-20230211122933114.png" alt="image-20230211122933114"></p>
<p><strong>文件权限</strong></p>
<blockquote>
<p>r read可读</p>
<p>w write可写</p>
<p>x executable可以执行</p>
<p>- 可以执行如shell等脚本</p>
</blockquote>
<p><strong>文件夹权限</strong></p>
<p>这里测试权限不要用root，root权限太强</p>
<p>请用普通用户执行。测试文件，文件夹权限操作请用普通用户</p>
<blockquote>
<p>r 可以对此目录执行ls列出所有文件</p>
<p>w 可以在这个目录创建文件，<em>文件夹必须先有x权限，才可以在文件夹中，创建新文件，包括touch mkdir等操作</em></p>
<p>x 可以cd进入这个目录，或者查看详细信息</p>
</blockquote>
<p><strong>更改文件权限的命令</strong></p>
<p>chmod u+x filename.txt #给文件的user属主添加可执行权限，u代表user，x代表exec</p>
<p>chmod 0 filename.txt #取消文件所有权限</p>
<p><strong>chmod命令</strong></p>
<p>chmod命令用来变更文件或者目录的权限。</p>
<p>设置方式以字母形式或者数字代号均可</p>
<p><img src="/../img/image-20230211141017515.png" alt="image-20230211141017515"></p>
<p><img src="/../img/image-20230211141856190.png" alt="image-20230211141856190"></p>
<p><em>文件属性的修改</em></p>
<p>a 所有用户</p>
<p>u 属主权限</p>
<p>g 属组权限</p>
<p>o 其他用户权限</p>
<p>chmod a&#x3D;r filename.txt #一次性修改文件的user group other权限为r</p>
<p><strong>chown命令</strong></p>
<p>修改文件属主，属组信息</p>
<p>chown 新属主的名字 文件&#x2F;文件夹</p>
<p>chown :属组 文件&#x2F;文件夹 #修改文件的属组</p>
<p>chown 属主:属组 文件 #同时修改文件的属主和属组</p>
<p>-R 递归修改文件的属主，属组 （改文件夹及其内部所有东西）</p>
<p><strong>umask命令</strong></p>
<p>umask命令用来限制新文件权限的掩码。<em>最高权限为777</em></p>
<p>Linux默认设置创建文件的最大权限是666，文件夹的权限最大时777</p>
<p>也称之为遮罩码，防止文件&#x2F;文件夹创建的时候，权限过大</p>
<p>当新文件被创建时，其最初的权限由文件创建掩码决定。</p>
<p>用户每次注册进入系统时，umask命令都被执行，并自动设置掩码改变默认值，新的权限会把旧的覆盖</p>
<p><em>umask默认配置在&#x2F;etc&#x2F;profile 61-64行</em></p>
<p><img src="/../img/image-20230211152715083.png" alt="image-20230211152715083"></p>
<p><img src="/../img/image-20230211152902921.png" alt="image-20230211152902921"></p>
<p><strong>chattr命令</strong></p>
<p>chattr命令用于更改文件的扩展属性，比chmod更改的rwx权限更底层</p>
<blockquote>
<p>参数</p>
<p>a: 只能像文件中添加数据，不得删除</p>
<p>chattr +a filename.txt</p>
<p>chattr -a filemame.txt</p>
<p>-R: 递归更改目录属性</p>
<p>-V: 显示命令执行过程</p>
<p>-i: 文件不能被删除，改名，修改内容</p>
<p>列出文件的特殊权限</p>
<p>lsattr filename.txt</p>
</blockquote>
<hr>
<h3 id="Linux通配符"><a href="#Linux通配符" class="headerlink" title="Linux通配符"></a>Linux通配符</h3><p><strong>通配符</strong></p>
<p>就是键盘上的一些特殊字符，可以实现特殊的功能，例如模糊搜索一些文件。</p>
<p>. 指代匹配一个字符</p>
<p><img src="E:\Blog\source\img\image-20230211154447842.png" alt="image-20230211154447842"></p>
<p><strong>常见通配符</strong></p>
<p>[]符号 匹配括号中的任意一个字符</p>
<p><img src="/../img/image-20230211154654224.png" alt="image-20230211154654224"></p>
<p><strong>特殊通配符</strong></p>
<p><img src="/../img/image-20230211154835672.png" alt="image-20230211154835672"></p>
<p><strong>路径相关</strong></p>
<p><img src="/../img/image-20230211160951933.png" alt="image-20230211160951933"></p>
<p><strong>特殊引号</strong></p>
<p>在Linux系统中，单引号，双引号可以用于表示字符串</p>
<p><img src="/../img/image-20230211161206741.png" alt="image-20230211161206741"></p>
<p>反引号Case：命令解析的作用</p>
<blockquote>
<p>`date +%F`等同于$(date +%F) #输出当前系统时间</p>
<ol>
<li><p>创建以时间为文件名的文件</p>
<p>touch “`date +%T`“.txt</p>
<p>双引号可以解析反引号命令解析的内容，单引号则不可以</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h3><p><img src="/../img/image-20230211164535478.png" alt="image-20230211164535478"></p>
<p><strong>;号</strong></p>
<ul>
<li>命令的结束</li>
<li>命令间的分隔符</li>
<li>配置文件的注释符</li>
</ul>
<p><strong>#号</strong></p>
<ul>
<li>注释行</li>
<li>root身份提示符</li>
</ul>
<p><strong>|号</strong></p>
<ul>
<li>管道符，用于传输数据</li>
</ul>
<p>能一次出结果的命令，尽量不要二次过滤，效率并不高</p>
<p><strong>{}号</strong></p>
<ul>
<li>生成序列，一连串的文本</li>
</ul>
<p>echo {1..100}</p>
<p>echo {1,2,3}</p>
<ul>
<li>快速备份文件</li>
</ul>
<p>cp &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0{,.ori} #会将&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0复制到&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0.ori里面</p>
<ul>
<li>将变量括起来作为变量分隔符号</li>
</ul>
<p>echo $week # 结果为3</p>
<p>echo “$week_oldboy” # 输出为空，系统认为week_oldboy是整个变量</p>
<p>echo “${week}_oldboy” # 花括号中才会识别是变量，做了分割，3_oldboy</p>
<p><strong>逻辑操作符</strong></p>
<p>逻辑符既可以在Linux系统中直接用，也可以在Bash脚本中用</p>
<p><strong>&amp;&amp;</strong></p>
<p>前一个命令成功，再执行下一个命令</p>
<p><strong>||</strong></p>
<p>前一个命令失败，再执行下一个命令</p>
<p><strong>！</strong></p>
<ul>
<li>在bash中取反</li>
<li>在vim中强制性</li>
<li>查找历史命令中 !ls找出最近一次以ls开头的命令</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell Basic Knowledge Notes</title>
    <url>/2023/02/11/Shell%E5%8F%98%E9%87%8F%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="Shell变量核心基础与进阶"><a href="#Shell变量核心基础与进阶" class="headerlink" title="Shell变量核心基础与进阶"></a>Shell变量核心基础与进阶</h1><h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><p><strong>shell的作用</strong></p>
<ul>
<li>解释执行用户输入的命令或者程序</li>
<li>用户输入一条命令，shell就解释一条</li>
<li>键盘输入命令，Linux给予响应的方式，称之为交互式</li>
</ul>
<span id="more"></span>

<p><img src="/../img/image-20230211183201865.png" alt="image-20230211183201865"></p>
<p>shell是一块包裹着系统核心的壳，处于操作系统的做外层，与用户直接对话，把用户的输入<em>解释</em>给操作系统，然后处理操作系统的输出结果，输出到屏幕给用户看到结果</p>
<p><img src="/../img/image-20230211183549206.png" alt="image-20230211183549206"></p>
<p>对于C语言来说，如果想找到一个文件，需要先写出C语言代码，然后调用系统函数，通过gcc编译后，运行程序才能找到文件。</p>
<h2 id="什么是shell脚本"><a href="#什么是shell脚本" class="headerlink" title="什么是shell脚本"></a>什么是shell脚本</h2><p>当命令或者程序语句写在文件中，我们执行文件，读取其中的代码，这个程序文件就称之为shell脚本</p>
<p>在shell脚本中定义多条Linux命令以及循环控制语句，然后将这些Linux命令一次性执行完毕，执行脚本文件的方式称之为，非交互式方式</p>
<ul>
<li>windows存在<code>*.bat</code>批处理脚本</li>
<li>Linux中常用<code>*.sh</code>脚本文件</li>
</ul>
<p><strong>shell脚本规则</strong></p>
<p>在Linux系统中，shell脚本或者称之为（bash shell程序）通常都是vim编辑，由Linux命令&#x2F;bash shell指令，逻辑控制语句和注释信息组成。</p>
<h3 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a>Shebang</h3><p>计算机程序中，<code>Shebang</code>指的是出现在文本文件中的第一行的前两个字符<code>#!</code></p>
<p>用以指明用哪个解释器去读</p>
<p>在Unix系统中，程序会分析<code>Shebang</code>后面的内容，作为解释器的指令，例如</p>
<ul>
<li>以<code>#! /bin/sh</code>开头的文件，程序在执行的时候会调用<code>/bin/sh</code>，也就是bash解释器</li>
<li>以<code>#! /usr/bin/python</code>开头的文件，代表指定python解释器去执行 #yum就是python开发的</li>
<li>以<code>#! /usr/bin/env</code>解释器名称，是一种在不同平台上都能正确找到解释器的办法</li>
</ul>
<p>注意事项：</p>
<ul>
<li>如果脚本未指定<code>Shebang</code>，脚本执行的时候默认用当前shell去解释脚本，即<code>$SHELL</code></li>
<li>如果<code>Shebang</code>指定了可执行的解释器，如<code>/bin/bash /usr/bin/python</code>，脚本在执行时，文件名会作为参数传给解释器</li>
<li>如果<code>#!</code>指定的解释程序没有可执行权限，则会报错”bad interpreter：Premission denied“</li>
<li>如果<code>#!</code>指定的解释程序不是一个可执行文件，那么指定的解释程序会被忽略，转而交给当前的SHELL去执行这个脚本</li>
<li>如果<code>#!</code>指定的解释程序不存在，则会报错”bad interpreter：No such file or directory“</li>
<li><code>#!</code>之后的解释程序，需要写其绝对路径，他是不会自动到$PATH中寻找解释器的</li>
<li>如果你使用<code>bash test.sh</code>这样的命令来执行脚本，那么<code>#!</code>这一行会被忽略掉，解释器当然是用命令行中显式指定的bash</li>
<li>在执行某个脚本时，应该输入<code>./hello.sh</code>而不是<code>hello.sh</code>，不指定当前目录Linux会从PATH里面去找</li>
</ul>
<h3 id="脚本注释，脚本开发规范"><a href="#脚本注释，脚本开发规范" class="headerlink" title="脚本注释，脚本开发规范"></a>脚本注释，脚本开发规范</h3><ul>
<li>在shell脚本中，#后面的内容代表注释掉的内容，提供给开发者或者使用者观看</li>
<li>注释单独写一行，可以跟在命令后</li>
<li>尽量使用英文注释</li>
</ul>
<h3 id="执行shell脚本的方式"><a href="#执行shell脚本的方式" class="headerlink" title="执行shell脚本的方式"></a>执行shell脚本的方式</h3><ul>
<li><code>bash script.sh</code>或者<code>sh script.sh</code>，文件本身没有权限执行，没x权限，则使用的方法或脚本未指定<code>Shebang</code>，则推荐使用命令行显式指定执行方式</li>
<li>使用绝对&#x2F;相对路径执行脚本，需要文件有x权限</li>
<li><code>source script.sh</code>或者<code>. script.sh</code>代表执行的含义，<code>source</code>等于<code>.</code></li>
<li>少见的用法，<code>sh &lt; script.sh</code></li>
</ul>
<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>脚本语言是为了缩短传统的编写，编译，链接，运行过程而创建的计算机编程语言</p>
<p>shell脚本语言属于一种弱类型语言，无需声明变量类型，直接定义使用</p>
<p>强类型语言，必须先定义类型，确定是数字，字符串等，之后再赋予同类型的值</p>
<p>弱类型语言，在定义数据类型的时候，不用主动声明该类型，默认是一个字符串（shell）</p>
<h3 id="其他脚本语言"><a href="#其他脚本语言" class="headerlink" title="其他脚本语言"></a>其他脚本语言</h3><ul>
<li>PHP网页程序语言，用于web页面开发</li>
<li>Perl语言，擅长支持强大的正则表达式</li>
<li>Python</li>
</ul>
<h3 id="shell的优势"><a href="#shell的优势" class="headerlink" title="shell的优势"></a>shell的优势</h3><p>shell语言便于Linux操作系统内部应用，Linux底层命令支持shell语句，以及结合三剑客（grep，sed，awk）进行高级用法</p>
<h2 id="Bash基础特性"><a href="#Bash基础特性" class="headerlink" title="Bash基础特性"></a>Bash基础特性</h2><ul>
<li>bash是一个命令处理器，运行在文本窗口中，并能执行用户直接输入的命令</li>
<li>bash还能从文件中读取Linux命令，称之为脚本</li>
<li>bash支持通配符，管道，命令替换，条件判断等逻辑控制语句</li>
</ul>
<p><strong>命令历史</strong></p>
<p><em>Shell会保留其会话中用户执行的命令</em></p>
<ul>
<li>history命令 展示历史执行命令</li>
</ul>
<p>​		-c 清空历史命令</p>
<p>​		-r 恢复历史命令</p>
<ul>
<li>echo $HISTFILE #存放用户执行的历史命令,写入文件</li>
</ul>
<p>​		&#x2F;root&#x2F;.bash_history</p>
<ul>
<li><p>调用历史记录命令</p>
<p>! + 历史id # 快速执行历史命令</p>
<p>!! # 执行上次命令 或者 使用上下左右寻找</p>
</li>
</ul>
<p><strong>Bash特性汇总</strong></p>
<ul>
<li>文件路径tab补全</li>
<li>命令补全</li>
<li>快捷键ctrl + a,e,u,k,l</li>
<li>通配符</li>
<li>命令历史</li>
<li>命令别名</li>
<li>命令行展开</li>
</ul>
<h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><ul>
<li><p>变量定义与复制，注意变量与值之间不得有空格 </p>
<blockquote>
<p><code>name=&quot;yuzhang&quot;</code></p>
<p>变量名 name</p>
<p>变脸类型，bash默认所有变量都是字符串</p>
<p>bash变量是弱类型，无需实现声明类型，是将声明和赋值同时进行</p>
</blockquote>
</li>
<li><p>变量替换&#x2F;引用</p>
<blockquote>
<p>输出：<code>echo $music</code> <code>echo $&#123;music&#125;</code></p>
<p>可以省略花括号</p>
</blockquote>
</li>
<li><p>变量名定义规则</p>
<ol>
<li>见名知意</li>
<li>只能包含数字，字母，下划线</li>
<li>不能以数字开头，不能是关键字</li>
<li>不能用标点符号</li>
<li>严格区分大小写</li>
</ol>
</li>
<li><p>变量的作用域</p>
<ul>
<li>本地变量，只针对当前shell</li>
</ul>
<p><strong>pstree</strong>用于检查进程树，可以查看当前shell进程</p>
<p><img src="/../img/image-20230212151404591.png" alt="image-20230212151404591"></p>
<ul>
<li>环境变量，也成为全局变量，针对当前shell以及其任意子进程，环境变量也分<code>自定义</code>，<code>内置</code>两种环境变量</li>
<li>局部变量，针对在shell函数或者shell脚本中定义</li>
</ul>
</li>
<li><p>位置参数变量：用于shell脚本中传递的参数 例如：-l -i -d等等</p>
</li>
<li><p>特殊变量：shell内置的特殊功效变量</p>
<ul>
<li>$? # 用在echo $0 判断上一语句执行结果<ul>
<li>0：成功</li>
<li>1-255：失败</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义变量</p>
<ul>
<li>变量赋值</li>
<li>变量引用</li>
</ul>
</li>
</ul>
<h4 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h4><p><strong>参数传递</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l 参数</span><br><span class="line"></span><br><span class="line"># 参数的理解</span><br><span class="line">bash test.sh 参数1 参数2 参数3</span><br></pre></td></tr></table></figure>

<p>shell的特殊变量，用在如脚本，函数传递参数使用，有如下特殊的，位置参数变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$0 获取shell脚本文件名，以及脚本路径</span><br><span class="line">$n 获取shell脚本的第n个参数，n在1~9之间，如$1,$2,$9,大于9则需要写成$&#123;10&#125;,参数空格隔开</span><br><span class="line">$# 获取执行的shell脚本后面的参数总个数</span><br><span class="line">$* 获取shell脚本所有参数，不加引号等同于$@的作用，加上引号”$*“作用是接受所有参数为单个字符串</span><br><span class="line">$@ 不加引号效果同上，加引号，是接受所有参数为独立字符串，如&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; ...,空格保留</span><br></pre></td></tr></table></figure>

<p>**$<em>和$@的异同</em>*</p>
<ul>
<li>相同点<ul>
<li>都表示传递给函数或脚本的所有参数</li>
<li>当它们不被双引号包围时，它们之间没有任何区别</li>
</ul>
</li>
<li>不同点（被双引号包围时）<ul>
<li>“$*”会将所有的参数从整体上看作一份数据，而不是把每个参数都看作一个数据</li>
<li>“$@”仍然将每个参数看作一份数据，彼此之间是独立的</li>
</ul>
</li>
</ul>
<h4 id="特殊状态变量"><a href="#特殊状态变量" class="headerlink" title="特殊状态变量"></a>特殊状态变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$? 上一次命令执行状态返回值，0正确，非0失败</span><br><span class="line">$$ 当前shell脚本的进程号</span><br><span class="line">$! 上一次后台进程的PID</span><br><span class="line">$_ 取得上次命令的最后一个参数</span><br><span class="line"></span><br><span class="line">查找方式 man bash</span><br><span class="line">	搜索Special Parameters</span><br></pre></td></tr></table></figure>

<p><strong>CASE</strong></p>
<blockquote>
<ol>
<li><p>脚本控制返回值的玩法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$#</span>获取参数个数 -ne 表示不等于</span></span><br><span class="line"></span><br><span class="line">[ $# -ne 2 ] &amp;&amp; &#123;</span><br><span class="line">	echo &quot;must be two args&quot;</span><br><span class="line">	exit 119 #终止程序运行，且返回119的状态码，提供给当前shell的$?变量，若是在函数里可以return 119</span><br><span class="line">&#125;</span><br><span class="line">echo ”没毛病，就是两个参数“</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取上一次后台执行的程序，PID，$! 获取</p>
<p><em>怎么让程序后台执行</em></p>
<p><code>nohup ping baidu.com &amp; 1&gt; /dev/null</code> #&amp;表示后台执行</p>
<p><code>ps -ef|grep ping</code># 列出系统中当前运行的进程</p>
</li>
<li><p>$$ 获取当前脚本的ID</p>
<p>每次运行完脚本ID都会改变</p>
</li>
<li><p>$_ 获取上一次命令最后一个参数</p>
<p><code>echo $_</code></p>
</li>
</ol>
</blockquote>
<h3 id="不同的执行方式，不同的shell环境"><a href="#不同的执行方式，不同的shell环境" class="headerlink" title="不同的执行方式，不同的shell环境"></a>不同的执行方式，不同的shell环境</h3><p><strong>ANSWER</strong></p>
<ol>
<li>每次调用bash&#x2F;sh解释器执行脚本都会开启一个子shell，因此不会保留当前shell变量，通过<code>pstree</code>命令检查进程树【bash和sh是在子shell中运行子变量与父无关】</li>
<li>调用<code>source</code>或者<code>.</code>是在当前shell环境加载脚本，因此保留变量【source和.在父shell中运行变量】</li>
</ol>
<h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><p><strong>环境变量</strong></p>
<p>环境变量一般指的是用export内置命令导出的变量，用于定义shell的运行环境，保证shell命令的正确执行</p>
<p>通俗来说，就是能找出你的Linux服务器上的各种变量</p>
<p>shell通过环境变量确定登录的用户名，PATH路径，文件系统等各种应用</p>
<p>环境变量可以在命令行中临时创建，但是用户退出shell终端，变量即丢失，如果要永久生效，需要修改<em>环境变量配置文件</em></p>
<ul>
<li>每个用户都有自己的环境变量配置文件<code>~/.bash_profile</code>，<code>~/.bashrc</code>，而且以个人配置文件优先加载变量，读取。用户登录之后，会加载个人配置文件<code>~/.bash_profile</code>，<code>~/.bashrc</code>远程登陆用户特有文件</li>
<li>全局配置文件<code>/etc/profile</code>，<code>/etc/bashrc</code>，且系统建议最好创建在<code>/etc/profile.d</code>，而非直接修改主文件，修改全局配置文件，影响所有登陆系统的用户</li>
</ul>
<p><strong>检查环境变量的命令</strong></p>
<ul>
<li>set，输出所有变量，包括全局变量，局部变量 (<em>找到当前shell环境中的所有变量，以及sh脚本文件中定义的变量，但是同样不能跨父子shell进行查找</em>)</li>
<li>env，只显示全局变量 （<em>函数属于局部变量</em>）</li>
<li>declare，输出所有变量，如同set</li>
<li>export，显示和设置环境变量</li>
</ul>
<p><strong>撤销环境变量</strong></p>
<ul>
<li>unset 变量名，删除变量或函数</li>
</ul>
<p><strong>设置只读变量</strong></p>
<ul>
<li>readonly 只有shell结束时，只读变量失效</li>
</ul>
<p><strong>系统保留环境变量关键字</strong></p>
<p>bash内嵌了诸多环境变量，用于定义bash的工作环境</p>
<p><code>export |awk -F &#39;[ :=]&#39; &#39;&#123;print $3&#125;&#39;</code></p>
<h3 id="环境变量初始化与加载顺序"><a href="#环境变量初始化与加载顺序" class="headerlink" title="环境变量初始化与加载顺序"></a>环境变量初始化与加载顺序</h3><p><img src="/../img/image-20230212160720172.png" alt="image-20230212160720172"></p>
<h2 id="shell子串"><a href="#shell子串" class="headerlink" title="shell子串"></a>shell子串</h2><h3 id="bash一些基础的内置命令"><a href="#bash一些基础的内置命令" class="headerlink" title="bash一些基础的内置命令"></a>bash一些基础的内置命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo</span><br><span class="line">eval</span><br><span class="line">exec</span><br><span class="line">export</span><br><span class="line">read</span><br><span class="line">shift</span><br></pre></td></tr></table></figure>

<p><strong>echo命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n #不换行输出，echo本身默认携带换行输出</span><br><span class="line">-e #解析字符串中的特殊符号</span><br><span class="line">\n #换行</span><br><span class="line">\r #回车</span><br><span class="line">\t #制表符 四个空格</span><br><span class="line">\b #退格</span><br><span class="line"></span><br><span class="line">echo -e &quot;我看你挺\n好的&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印命令</span></span><br><span class="line">printf &quot;我是\t吴彦祖&quot;</span><br></pre></td></tr></table></figure>

<p><strong>eval命令</strong></p>
<p>执行多个命令，相当于把后面的命令等同于参数传给eval，然后eval进而执行他们</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval ls;cd /tmp</span><br></pre></td></tr></table></figure>

<p><strong>exec命令</strong></p>
<p>不创建子进程，执行后续命令，且执行完毕后自动exit</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec date</span><br></pre></td></tr></table></figure>

<h3 id="shell字串的花式语法"><a href="#shell字串的花式语法" class="headerlink" title="shell字串的花式语法"></a>shell字串的花式语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量&#125;	<span class="comment"># 返回变量值</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#变量&#125;	# 返回变量长度，字符长度</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量:start&#125;	<span class="comment"># 返回变量start数值之后的字符（start是数字，且包含start）</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量:start:length&#125;	<span class="comment"># 提取start之后的length限制的字符</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量<span class="comment">#word&#125;	# 从变量开头删除最短匹配的word子串</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量<span class="comment">##word&#125;	# 从变量开头删除最长匹配的word子串</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量%word&#125;	<span class="comment"># 从变量结尾删除最短匹配的word子串</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量%%word&#125;	<span class="comment"># 从变量结尾删除最长匹配的word子串</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量/pattern/string&#125;	<span class="comment"># 用string代替第一个匹配的pattern</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;变量//pattern/string&#125;	<span class="comment"># 用string代替所有匹配的pattern</span></span></span><br></pre></td></tr></table></figure>

<p><strong>字串的实际案例</strong></p>
<p><em>Shell变量截取字符串通常有两种方式：</em></p>
<ol>
<li>从指定位置开始截取</li>
<li>从指定字符（子字符串）开始截取</li>
</ol>
<p><strong>从指定位置开始截取</strong></p>
<p>这种方式需要两个参数：除了指定起始位置，还需要截取长度，才能最终确定要截取的字符串。</p>
<p>既然要制定起始位置，那么就涉及到计数方向的问题，到底是从字符串左边开始计数还是从字符串右边开始计数。答案是Shell同时支持两种计数方式。</p>
<ol>
<li><p>从字符串左边开始计数</p>
<p>如果想从字符串的左边开始计数，那么截取字符串的具体格式如下：</p>
<p><code>$&#123;string:start:length&#125;</code></p>
<p>其中，<code>string</code>是要截取的字符串，<code>start</code>是起始位置（从左边开始，从0开始计数），<code>length</code>是要截取的长度（省略的话表示直到字符串的末尾）</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;yuzhang180&quot;</span><br><span class="line">echo $&#123;name&#125; #yuzhang180</span><br><span class="line">echo $&#123;#name&#125; #10</span><br><span class="line">echo $&#123;name:3&#125; #zhang180</span><br><span class="line">echo $&#123;name:3:5&#125; #zhang</span><br></pre></td></tr></table></figure>

<p><strong>计算变量各种长度</strong></p>
<ul>
<li>多种统计长度的命令</li>
</ul>
<blockquote>
<p>echo $</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Clearblue配置</title>
    <url>/2023/02/15/Clearblue%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Clearblue-配置"><a href="#Clearblue-配置" class="headerlink" title="Clearblue 配置"></a>Clearblue 配置</h1><h2 id="Download-resources"><a href="#Download-resources" class="headerlink" title="Download resources"></a>Download resources</h2><p><a href="https://releases.llvm.org/download.html">https://releases.llvm.org/download.html</a></p>
<p><img src="/../img/image-20230216141408026.png" alt="image-20230216141408026"></p>
<span id="more"></span>

<h2 id="Move-resources-to-HOME"><a href="#Move-resources-to-HOME" class="headerlink" title="Move resources to $HOME"></a>Move resources to $HOME</h2><p>Use FileZila(Windows)</p>
<h2 id="Build-LLVM-3-6-2"><a href="#Build-LLVM-3-6-2" class="headerlink" title="Build LLVM(3.6.2)"></a>Build LLVM(3.6.2)</h2><ul>
<li>put clang src codes into llvm-3.6.2.src&#x2F;tools (clang and llvm version are all 3.6.2)</li>
<li>There is a code irregularity in one place(&#x2F;home&#x2F;zhuyuzhang&#x2F;llvm-3.6.2.src&#x2F;include&#x2F;llvm&#x2F;IR&#x2F;Valuemap.h:104:31) use cmpulsory conversion to bool</li>
<li>mkdir build &amp;&amp; cd build [&#x2F;home&#x2F;zhuyuzhang&#x2F;llvm-3.6.2.src&#x2F;build]</li>
<li>cmake .. -DCMAKE_BUILD_TYPE&#x3D;Debug -DLLVM_ENABLE_RTTI&#x3D;ON</li>
<li>make -j10</li>
</ul>
<h2 id="Build-Clearblue"><a href="#Build-Clearblue" class="headerlink" title="Build Clearblue"></a>Build Clearblue</h2><ul>
<li>cd clearblue</li>
<li>git submodule update –init –recursive</li>
<li>mkdir build &amp;&amp; cd build</li>
<li>cmake ..&#x2F; -DLLVM_BUILD_PATH&#x3D;&#x2F;home&#x2F;zhuyuzhang&#x2F;llvm-3.6.2.src&#x2F;build -DLLVM_BUILD_MAIN_SRC_DIR&#x3D;&#x2F;home&#x2F;zhuyuzhang&#x2F;llvm-3.6.2.src</li>
<li>make -j120</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul>
<li>scl enable devtoolset-8 bash(update gcc)</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Clearblue</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM learning notes1: The Architecture of Open Source Applications: LLVM</title>
    <url>/2023/03/14/LLVM-learning-notes1-The-Architecture-of-Open-Source-Applications-LLVM/</url>
    <content><![CDATA[<p><a href="http://www.aosabook.org/en/llvm.html">Resource</a></p>
<h1 id="Classical-Complier-Design"><a href="#Classical-Complier-Design" class="headerlink" title="Classical Complier Design"></a>Classical Complier Design</h1><p><img src="/../img/image-20230314215732944.png" alt="image-20230314215732944"></p>
<p><strong>The front end</strong> parses source code, checking it for errors, and builds a language-specific Abstract Syntax Tree (AST) to represent the input code.</p>
<p><strong>The optimizer</strong>  is responsible for doing a broad variety of transformations to try to improve the code’s running time. It is usually more or less independent of language and target.</p>
<p><strong>The back end</strong> (also known as the code generator) then maps the code onto the target instruction set. In addition to making <em>correct</em> code, it is responsible for generating <em>good</em> code that takes advantage of unusual features of the supported architecture.</p>
<span id="more"></span>

<h1 id="LLVM’s-Code-Representation-LLVM-IR"><a href="#LLVM’s-Code-Representation-LLVM-IR" class="headerlink" title="LLVM’s Code Representation: LLVM IR"></a>LLVM’s Code Representation: LLVM IR</h1><p>The most important aspect of its design is the LLVM Intermediate Representation (IR), which is the form it uses to represent code in the compiler. LLVM IR is designed to host mid-level analyses and transformations that you find in the optimizer section of a compiler. It was designed with many specific goals in mind, including supporting lightweight runtime optimizations, cross-function&#x2F;interprocedural optimizations, whole program analysis, and aggressive restructuring transformations, etc. The most important aspect of it, though, is that it is itself defined as a first class language with well-defined semantics.</p>
<h1 id="Writing-an-LLVM-IR-Optimization"><a href="#Writing-an-LLVM-IR-Optimization" class="headerlink" title="Writing an LLVM IR Optimization"></a>Writing an LLVM IR Optimization</h1><p>That said, most optimizations follow a simple three-part structure:</p>
<ul>
<li>Look for a pattern to be transformed.</li>
<li>Verify that the transformation is safe&#x2F;correct for the matched instance.</li>
<li>Do the transformation, updating the code.</li>
</ul>
<p>The caller of this function (<code>SimplifyInstruction</code>) is a dispatcher that does a switch on the instruction opcode, dispatching to the per-opcode helper functions. It is called from various optimizations. A simple driver looks like this:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock::iterator I = BB-&gt;<span class="built_in">begin</span>(), E = BB-&gt;<span class="built_in">end</span>(); I != E; ++I)</span><br><span class="line">  <span class="keyword">if</span> (Value *V = <span class="built_in">SimplifyInstruction</span>(I))</span><br><span class="line">    I-&gt;<span class="built_in">replaceAllUsesWith</span>(V);</span><br></pre></td></tr></table></figure>

<p>This code simply loops over each instruction in a block, checking to see if any of them simplify. If so (because <code>SimplifyInstruction</code> returns non-null), it uses the <code>replaceAllUsesWith</code> method to update anything in the code using the simplifiable operation with the simpler form.</p>
<h1 id="LLVM’s-Implementation-of-Three-Phase-Design"><a href="#LLVM’s-Implementation-of-Three-Phase-Design" class="headerlink" title="LLVM’s Implementation of Three-Phase Design"></a>LLVM’s Implementation of Three-Phase Design</h1><h2 id="LLVM-IR-is-a-Complete-Code-Representation"><a href="#LLVM-IR-is-a-Complete-Code-Representation" class="headerlink" title="LLVM IR is a Complete Code Representation"></a>LLVM IR is a Complete Code Representation</h2><p>LLVM IR is both well specified and the <em>only</em> interface to the optimizer. This property means that all you need to know to write a front end for LLVM is what LLVM IR is, how it works, and the invariants it expects. Since LLVM IR has a first-class textual form, it is both possible and reasonable to build a front end that outputs LLVM IR as text, then uses Unix pipes to send it through the optimizer sequence and code generator of your choice.</p>
<h2 id="LLVM-is-a-Collection-of-Libraries"><a href="#LLVM-is-a-Collection-of-Libraries" class="headerlink" title="LLVM is a Collection of Libraries"></a>LLVM is a Collection of Libraries</h2><p>LLVM optimizer provides dozens of different passes, each of which are written in a similar style. These passes are compiled into one or more <code>.o</code> files, which are then built into a series of archive libraries (<code>.a</code> files on Unix systems). </p>
<p><img src="/../img/image-20230326172542361.png" alt="image-20230326172542361"></p>
<p>In our example above, since there is a reference to PassA and PassB, they will get linked in. Since PassB uses PassD to do some analysis, PassD gets linked in. However, since PassC (and dozens of other optimizations) aren’t used, its code isn’t linked into the image processing application.</p>
<p>This is where the power of the library-based design of LLVM comes into play. This straightforward design approach allows LLVM to provide a vast amount of capability, some of which may only be useful to specific audiences, without punishing clients of the libraries that just want to do simple things. In contrast, traditional compiler optimizers are built as a tightly interconnected mass of code, which is much more difficult to subset, reason about, and come up to speed on. With LLVM you can understand individual optimizers without knowing how the whole system fits together.</p>
<p>This library-based design is also the reason why so many people misunderstand what LLVM is all about: the LLVM libraries have many capabilities, but they don’t actually <em>do</em> anything by themselves. It is up to the designer of the client of the libraries (e.g., the Clang C compiler) to decide how to put the pieces to best use. This careful layering, factoring, and focus on subset-ability is also why the LLVM optimizer can be used for such a broad range of different applications in different contexts. Also, just because LLVM provides JIT compilation capabilities, it doesn’t mean that every client uses it.</p>
<h1 id="Design-of-the-Retargetable-LLVM-Code-Generator"><a href="#Design-of-the-Retargetable-LLVM-Code-Generator" class="headerlink" title="Design of the Retargetable LLVM Code Generator"></a>Design of the Retargetable LLVM Code Generator</h1><p>Similar to the approach in the optimizer, LLVM’s code generator splits the code generation problem into individual passes—instruction selection, register allocation, scheduling, code layout optimization, and assembly emission—and provides many builtin passes that are run by default.</p>
<h2 id="LLVM-Target-Description-Files"><a href="#LLVM-Target-Description-Files" class="headerlink" title="LLVM Target Description Files"></a>LLVM Target Description Files</h2><p>The “mix and match” approach allows target authors to choose what makes sense for their architecture and permits a large amount of code reuse across different targets. This brings up another challenge: each shared component needs to be able to reason about target specific properties in a generic way. For example, a shared register allocator needs to know the register file of each target and the constraints that exist between instructions and their register operands. LLVM’s solution to this is for each target to provide a target description in a declarative domain-specific language (a set of <code>.td</code> files) processed by the tblgen tool. The (simplified) build process for the x86 target is shown in <a href="http://www.aosabook.org/en/llvm.html#fig.llvm.x86">Figure 11.5</a>.</p>
<p><img src="/../img/image-20230326180400432.png" alt="image-20230326180400432"></p>
<h1 id="Interesting-Capabilities-Provided-by-a-Modular-Design"><a href="#Interesting-Capabilities-Provided-by-a-Modular-Design" class="headerlink" title="Interesting Capabilities Provided by a Modular Design"></a>Interesting Capabilities Provided by a Modular Design</h1><h2 id="Choosing-When-and-Where-Each-Phase-Runs"><a href="#Choosing-When-and-Where-Each-Phase-Runs" class="headerlink" title="Choosing When and Where Each Phase Runs"></a>Choosing When and Where Each Phase Runs</h2><p>As mentioned earlier, LLVM IR can be efficiently (de)serialized to&#x2F;from a binary format known as LLVM bitcode. Since LLVM IR is self-contained, and serialization is a lossless process, we can do part of compilation, save our progress to disk, then continue work at some point in the future. This feature provides a number of interesting capabilities including support for link-time and install-time optimization, both of which delay code generation from “compile time”.</p>
<p>Link-Time Optimization (LTO) addresses the problem where the compiler traditionally only sees one translation unit (e.g., a <code>.c</code> file with all its headers) at a time and therefore cannot do optimizations (like inlining) across file boundaries. LLVM compilers like Clang support this with the <code>-flto</code> or <code>-O4</code> command line option. This option instructs the compiler to emit LLVM bitcode to the <code>.o</code>file instead of writing out a native object file, and delays code generation to link time, shown in <a href="http://www.aosabook.org/en/llvm.html#fig.llvm.lto">Figure 11.6</a>.</p>
<p><img src="/../img/image-20230326200108501.png" alt="image-20230326200108501"></p>
<h2 id="Unit-Testing-the-Optimizer"><a href="#Unit-Testing-the-Optimizer" class="headerlink" title="Unit Testing the Optimizer"></a>Unit Testing the Optimizer</h2><p>By using the textual form of LLVM IR with the modular optimizer, the LLVM test suite has highly focused regression tests that can load LLVM IR from disk, run it through exactly one optimization pass, and verify the expected behavior. Beyond crashing, a more complicated behavioral test wants to verify that an optimization is actually performed. Here is a simple test case that checks to see that the constant propagation pass is working with add instructions:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; RUN: opt &lt; %s -constprop -S | FileCheck %s</span><br><span class="line">define i32 @test() &#123;</span><br><span class="line">  %A = add i32 4, 5</span><br><span class="line">  ret i32 %A</span><br><span class="line">  ; CHECK: @test()</span><br><span class="line">  ; CHECK: ret i32 9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>RUN</code> line specifies the command to execute: in this case, the <code>opt</code> and <code>FileCheck</code> command line tools. The <code>opt</code> program is a simple wrapper around the LLVM pass manager, which links in all the standard passes (and can dynamically load plugins containing other passes) and exposes them through to the command line. The <code>FileCheck</code> tool verifies that its standard input matches a series of <code>CHECK</code> directives. In this case, this simple test is verifying that the <code>constprop</code> pass is folding the <code>add</code> of 4 and 5 into 9.</p>
<p>While this might seem like a really trivial example, this is very difficult to test by writing .c files: front ends often do constant folding as they parse, so it is very difficult and fragile to write code that makes its way downstream to a constant folding optimization pass. Because we can load LLVM IR as text and send it through the specific optimization pass we’re interested in, then dump out the result as another text file, it is really straightforward to test exactly what we want, both for regression and feature tests.</p>
<h2 id="Automatic-Test-Case-Reduction-with-BugPoint"><a href="#Automatic-Test-Case-Reduction-with-BugPoint" class="headerlink" title="Automatic Test Case Reduction with BugPoint"></a>Automatic Test Case Reduction with BugPoint</h2><p>The LLVM BugPoint tool<a href="http://www.aosabook.org/en/llvm.html#footnote-7">7</a> uses the IR serialization and modular design of LLVM to automate this process. For example, given an input <code>.ll</code> or <code>.bc</code> file along with a list of optimization passes that causes an optimizer crash, BugPoint reduces the input to a small test case and determines which optimizer is at fault. It then outputs the reduced test case and the <code>opt</code> command used to reproduce the failure. It finds this by using techniques similar to “delta debugging” to reduce the input and the optimizer pass list. Because it knows the structure of LLVM IR, BugPoint does not waste time generating invalid IR to input to the optimizer, unlike the standard “delta” command line tool.</p>
<p>In the more complex case of a miscompilation, you can specify the input, code generator information, the command line to pass to the executable, and a reference output. BugPoint will first determine if the problem is due to an optimizer or a code generator, and will then repeatedly partition the test case into two pieces: one that is sent into the “known good” component and one that is sent into the “known buggy” component. By iteratively moving more and more code out of the partition that is sent into the known buggy code generator, it reduces the test case.</p>
<h1 id="Retrospective-and-Future-Directions"><a href="#Retrospective-and-Future-Directions" class="headerlink" title="Retrospective and Future Directions"></a>Retrospective and Future Directions</h1>]]></content>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Tai-e-A1</title>
    <url>/2023/06/21/Tai-e-A1/</url>
    <content><![CDATA[<h1 id="活跃变量分析和迭代求解器"><a href="#活跃变量分析和迭代求解器" class="headerlink" title="活跃变量分析和迭代求解器"></a>活跃变量分析和迭代求解器</h1><p>用来记录思维变化过程，思考误区，代码理解。</p>
<span id="more"></span>

<h2 id="实现活跃变量分析"><a href="#实现活跃变量分析" class="headerlink" title="实现活跃变量分析"></a>实现活跃变量分析</h2><h3 id="newBoundaryFact"><a href="#newBoundaryFact" class="headerlink" title="newBoundaryFact"></a>newBoundaryFact</h3><p><font color=red><strong>Class SetFact ：</strong> </font>用于代表在程序中某点的活跃变量（直到Exit）</p>
<p><font color=red><strong>Class Var ：</strong> </font>用于代表变量</p>
<p><font color=green><strong>思考误区 ：</strong> </font>对于某点的SetFact并不是需要存储所有变量，然后看变量是否含有某特征表示是否活跃。SetFact只需要存储活跃的变量即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">        <span class="comment">// IN[Exit] = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="newInitialFact"><a href="#newInitialFact" class="headerlink" title="newInitialFact"></a>newInitialFact</h3><p><font color=green><strong>思考误区 ：</strong> </font>并不需要找到所有statement然后给对应的IN[stmt]赋值，只考虑当前程序中对应点的statement。因为现有接口不足以找到全部数量的statement。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// IN[stmt] = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="meetInto"><a href="#meetInto" class="headerlink" title="meetInto"></a>meetInto</h3><p><font color=blue><strong>Tips ：</strong> </font>把每一个IN塞入OUT中。还可以忽略一些不变的 <code>IN fact</code> 来提高效率。例如在某次迭代中，如果 <code>IN[S2]</code> 有改变而 <code>IN[S3]</code> 没有，我们就不必依照课堂上讲述的办法求出 <code>IN[S2]</code> 和 <code>IN[S3]</code> 的并，而大可以忽略 <code>IN[S3]</code>，只把 <code>IN[S2]</code> 并入 <code>OUT[S1]</code>。</p>
<p><img src="/../img/image-20230621235050492.png" alt="image-20230621235050492"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[stmt] = Union of IN[all successor of stmt]</span></span><br><span class="line">        target.union(fact);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="transferNode"><a href="#transferNode" class="headerlink" title="transferNode"></a>transferNode</h3><p><font color=blue><strong>Tips ：</strong> </font>在进行强制类型转换之前必须要利用instanceof检查</p>
<p><font color=green><strong>思考误区 ：</strong> </font>isChange需要两者不等，导致IterativeSolver进入死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">        <span class="comment">// IN[stmt] = USE[stmt] Union (OUT[stmt] - DEF[stmt])</span></span><br><span class="line">        SetFact&lt;Var&gt; inNew = out.copy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OUT[stmt] - DEF[stmt]</span></span><br><span class="line">        Optional&lt;LValue&gt; optional = stmt.getDef();</span><br><span class="line">        <span class="keyword">if</span>(optional.isPresent()) &#123;</span><br><span class="line">            <span class="type">LValue</span> <span class="variable">lValue</span> <span class="operator">=</span> optional.get();</span><br><span class="line">            <span class="keyword">if</span> (lValue <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">def</span> <span class="operator">=</span> (Var) lValue;</span><br><span class="line">                <span class="keyword">if</span>(inNew.contains(def)) &#123;</span><br><span class="line">                    inNew.remove(def);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//USE[stmt]</span></span><br><span class="line">        List&lt;RValue&gt; rValueList = stmt.getUses();</span><br><span class="line">        List&lt;Var&gt; useList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RValue rValue : rValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rValue <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">use</span> <span class="operator">=</span> (Var) rValue;</span><br><span class="line">                useList.add(use);</span><br><span class="line">                inNew.add(use);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Compare</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isChange</span> <span class="operator">=</span> !inNew.equals(in);</span><br><span class="line">        <span class="keyword">if</span>(isChange) &#123;</span><br><span class="line">            in.set(inNew);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isChange;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现迭代求解器"><a href="#实现迭代求解器" class="headerlink" title="实现迭代求解器"></a>实现迭代求解器</h2><h3 id="initializeBackward"><a href="#initializeBackward" class="headerlink" title="initializeBackward"></a>initializeBackward</h3><p><font color=blue><strong>Tips ：</strong> </font>对算法前三行进行实现，要将OUT初始化与IN一样，因为meetInto函数是逐个将IN合并进入OUT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// IN[Exit] = null IN[stmt] = null</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">exit</span> <span class="operator">=</span> cfg.getExit();</span><br><span class="line">        <span class="type">Fact</span> <span class="variable">exitInFact</span> <span class="operator">=</span> analysis.newBoundaryFact(cfg);</span><br><span class="line">        result.setInFact(exit, exitInFact);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node stmt : cfg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cfg.isExit(stmt)) &#123;</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">stmtInFact</span> <span class="operator">=</span> analysis.newInitialFact();</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">stmtOutFact</span> <span class="operator">=</span> analysis.newInitialFact();</span><br><span class="line">                result.setInFact(stmt, stmtInFact);</span><br><span class="line">                result.setOutFact(stmt, stmtOutFact);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="doSolveBackward"><a href="#doSolveBackward" class="headerlink" title="doSolveBackward"></a>doSolveBackward</h3><p><font color=blue><strong>Tips ：</strong> </font>使用do while实现循环更加方便，因为条件变量更容易判断，一旦有变化就设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// While loop</span></span><br><span class="line">        <span class="type">boolean</span> isChange;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            isChange = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node stmt : cfg) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!cfg.isExit(stmt)) &#123;</span><br><span class="line">                    <span class="type">Fact</span> <span class="variable">outStmt</span> <span class="operator">=</span> result.getOutFact(stmt);</span><br><span class="line">                    <span class="keyword">for</span>(Node suc : cfg.getSuccsOf(stmt)) &#123;</span><br><span class="line">                        <span class="type">Fact</span> <span class="variable">inSuc</span> <span class="operator">=</span> result.getInFact(suc);</span><br><span class="line">                        analysis.meetInto(inSuc, outStmt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">Fact</span> <span class="variable">inStmt</span> <span class="operator">=</span> result.getInFact(stmt);</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">tmp</span> <span class="operator">=</span> analysis.transferNode(stmt, inStmt, outStmt);</span><br><span class="line">                    <span class="keyword">if</span>(tmp) isChange = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (isChange);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tai-e assignment</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Static Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Tai-e-A2</title>
    <url>/2023/06/29/Tai-e-A2/</url>
    <content><![CDATA[<h1 id="常量传播和-Worklist-求解器"><a href="#常量传播和-Worklist-求解器" class="headerlink" title="常量传播和 Worklist 求解器"></a>常量传播和 Worklist 求解器</h1><p>PASCAL OJ太痛苦了，有很多奇怪的判断点啊，经过和答案比对，总算找到了问题</p>
<p><img src="/../img/image-20230705204801604.png" alt="image-20230705204801604"></p>
<span id="more"></span>

<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ol>
<li>虽然已经注意到了DIV操作和REM操作中<code>operator2</code>值为<code>0</code>情况，但是写代码的时候我的判断是<code>operator1</code>和<code>operator2</code>均为<code>constant</code>的情况，而此时不应该考虑<code>operator1</code>只要<code>operator2</code>为<code>0</code>在这两种操作符下，就应该<code>return Value.getUNDEF()</code>。</li>
<li><code>newBoundaryFact</code>函数初始化边界条件时，如果<code>var</code>不能赋予<code>int</code>类型值就不应该初始化！！但是！！自己跑的testcase不初始化就会跑不过。</li>
<li><code>transferNode</code>函数中针对<code>i++</code>操作，不应该针对<code>in</code>进行<code>remove(def)</code>操作，否则不能对<code>i</code>值正确累加，因为在<code>evaluate</code>函数需要取<code>in</code>中<code>def</code>对应的<code>Value</code>值，正确的方法应该是将<code>in</code>其他<code>var</code>全部更新进入<code>out</code>，最后<code>evaluate</code>对应的<code>def</code>，再进行<code>update</code>。</li>
<li>最后一个！！也是最不理解的，根据公式OUT &#x3D; GEN ∪ (IN - KILL)，答案是将IN所有变量加入OUT相当于OUT∪IN。（不影响，是自己的实现中<code>canHoldInt</code>判断后赋值NAC导致的）</li>
</ol>
<h2 id="实现常量传播"><a href="#实现常量传播" class="headerlink" title="实现常量传播"></a>实现常量传播</h2><h3 id="newBoundaryFact"><a href="#newBoundaryFact" class="headerlink" title="newBoundaryFact"></a>newBoundaryFact</h3><p><font color=red><strong>Class CPFact ：</strong> </font>用于代表在程序中某点的常量状态（包括<code>UNDEF</code>，<code>CONSTANT</code>，<code>NAC</code>）</p>
<p><font color=red><strong>Class Value ：</strong> </font>用来表征<code>NAC</code>，<code>C</code>，<code>UNDEF</code></p>
<p><font color=green><strong>思考误区 ：</strong> </font>在此应该将所有变量初始化为<code>NAC</code>而不是<code>UNDEF</code>，记得设置为<code>NAC</code>。（因为不分析过程外的方法，这里可能返回任何值，需要做最保守的假设。显然这是sound但是不精确的。<strong>（还是不太理解，如果在meet的时候那永远都是NAC）</strong></p>
<p><font color=blue><strong>Tips ：</strong> </font></p>
<ol>
<li>对于除以 <code>0</code> 的情况（出现在 <code>/</code> 和 <code>%</code> 中），我们规定结果为 <code>UNDEF</code>。例如，对于 <code>x = a / 0</code>，<code>x</code> 的值将会是 <code>UNDEF</code>。</li>
<li>条件表达式（如 <code>a == b</code>）的值由 <code>0</code>（若为 <code>False</code>）和 <code>1</code>（若为 <code>True</code>）来表示。</li>
<li>要用cfg.getIR().getParams()获得方法的参数（不是getVars，这个是变量+%this）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CPFact <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[Entry] = NAC</span></span><br><span class="line">        <span class="type">CPFact</span> <span class="variable">entryCPFact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPFact</span>();</span><br><span class="line">        <span class="type">Value</span> <span class="variable">entryInit</span> <span class="operator">=</span> Value.getNAC();</span><br><span class="line">        List&lt;Var&gt; varList = cfg.getIR().getParams();</span><br><span class="line">        <span class="keyword">for</span>(Var <span class="keyword">var</span> : varList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(canHoldInt(<span class="keyword">var</span>)) &#123;<span class="comment">//For OJ</span></span><br><span class="line">                entryCPFact.update(<span class="keyword">var</span>, entryInit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//entryCPFact.update(var, entryInit);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entryCPFact;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="newInitialFact"><a href="#newInitialFact" class="headerlink" title="newInitialFact"></a>newInitialFact</h3><p><font color=blue><strong>Tips ：</strong> </font></p>
<ol>
<li>CPFact类对于UNDEF的variable，它用absence来代表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CPFact <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[stmt] = UNDEF</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CPFact</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="meetInto"><a href="#meetInto" class="headerlink" title="meetInto"></a>meetInto</h3><p><font color=blue><strong>Tips ：</strong> </font>原理和A1相同，Merge进入target中。需要调用meetValue，在这里处理了meetValue第三种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(CPFact fact, CPFact target)</span> &#123;</span><br><span class="line">        <span class="comment">// Merge fact into target</span></span><br><span class="line">        Set&lt;Var&gt; keySet = fact.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Var key : keySet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target.get(key) != <span class="literal">null</span>) &#123;<span class="comment">// target contains key</span></span><br><span class="line">                <span class="type">Value</span> <span class="variable">targetKeyValue</span> <span class="operator">=</span> target.get(key);</span><br><span class="line">                <span class="type">Value</span> <span class="variable">tempKeyValue</span> <span class="operator">=</span> fact.get(key);</span><br><span class="line">                <span class="type">Value</span> <span class="variable">targetValue</span> <span class="operator">=</span> meetValue(targetKeyValue, tempKeyValue);</span><br><span class="line">                target.update(key, targetValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//target does not contain key</span></span><br><span class="line">                target.update(key, fact.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="meetValue"><a href="#meetValue" class="headerlink" title="meetValue"></a>meetValue</h3><p><font color=blue><strong>Tips ：</strong> </font>Control flow merge, meet 操作的三种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Value <span class="title function_">meetValue</span><span class="params">(Value v1, Value v2)</span> &#123;</span><br><span class="line">        <span class="comment">// Three situations</span></span><br><span class="line">        <span class="comment">// 1. val and NAC</span></span><br><span class="line">        <span class="keyword">if</span>(v1.isNAC() || v2.isNAC()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. val and UNDEF</span></span><br><span class="line">        <span class="keyword">if</span>((v1.isUndef() &amp;&amp; v2.isConstant()) ||(v1.isConstant()) &amp;&amp; v2.isUndef()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v1.isConstant()) &#123;</span><br><span class="line">                <span class="keyword">return</span> v1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v2.isConstant())&#123;</span><br><span class="line">                <span class="keyword">return</span> v2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. val1 = val2</span></span><br><span class="line">        <span class="keyword">if</span>(v1.isConstant() &amp;&amp; v2.isConstant())  &#123;</span><br><span class="line">            <span class="keyword">if</span>(v1.equals(v2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> v1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="transferNode"><a href="#transferNode" class="headerlink" title="transferNode"></a>transferNode</h3><p><font color=blue><strong>Tips ：</strong> </font></p>
<ol>
<li><code>boolean byte char short</code>四种类型都是通过<code>int</code>计算。</li>
<li><code>DefinitionStmt&lt;?, ?&gt; defStmt = (DefinitionStmt&lt;?, ?&gt;) stmt;</code>用于将stmt转化为其子类，从而获取左右值</li>
<li>对于除以 <code>0</code> 的情况（出现在 <code>/</code> 和 <code>%</code> 中），我们规定结果为 <code>UNDEF</code>。例如，对于 <code>x = a / 0</code>，<code>x</code> 的值将会是 <code>UNDEF</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[stmt] = GEN[stmt] Union (IN[stmt] - KILL[stmt])</span></span><br><span class="line">        <span class="type">CPFact</span> <span class="variable">oriOut</span> <span class="operator">=</span> out.copy();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> DefinitionStmt) &#123;</span><br><span class="line">            DefinitionStmt&lt;?, ?&gt; defStmt = (DefinitionStmt&lt;?, ?&gt;) stmt;</span><br><span class="line">            <span class="type">LValue</span> <span class="variable">lValue</span> <span class="operator">=</span> defStmt.getLValue();</span><br><span class="line">            <span class="type">RValue</span> <span class="variable">rValue</span> <span class="operator">=</span> defStmt.getRValue();</span><br><span class="line">            <span class="keyword">if</span> (lValue <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">def</span> <span class="operator">=</span> (Var) lValue;</span><br><span class="line">                <span class="comment">//in.remove(def);// KILL</span></span><br><span class="line">                Value result;</span><br><span class="line">                result = evaluate(rValue, in);</span><br><span class="line">                <span class="keyword">if</span> (!result.isUndef() &amp;&amp; canHoldInt(def)) &#123;</span><br><span class="line">                    in.update(def, result);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!result.isUndef() &amp;&amp; !canHoldInt(def)) &#123;</span><br><span class="line">                    in.update(def, Value.getNAC());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.clear();</span><br><span class="line">        out.copyFrom(in);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> !out.equals(oriOut);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[stmt] = GEN[stmt] Union (IN[stmt] - KILL[stmt])</span></span><br><span class="line">        <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> DefinitionStmt) &#123;</span><br><span class="line">            DefinitionStmt&lt;?, ?&gt; defStmt = (DefinitionStmt&lt;?, ?&gt;) stmt;</span><br><span class="line">            <span class="type">Exp</span> <span class="variable">lValue</span> <span class="operator">=</span> defStmt.getLValue();</span><br><span class="line">            <span class="type">Exp</span> <span class="variable">rValue</span> <span class="operator">=</span> defStmt.getRValue();</span><br><span class="line">            <span class="keyword">if</span> (lValue <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">def</span> <span class="operator">=</span> (Var) lValue;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isChange</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Save result into out</span></span><br><span class="line">                <span class="keyword">for</span>(Var <span class="keyword">var</span> : in.keySet()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="keyword">var</span>.equals(def)) &#123; <span class="comment">//KILL[stmt]</span></span><br><span class="line">                        isChange |= out.update(<span class="keyword">var</span>, in.get(<span class="keyword">var</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Value result;</span><br><span class="line">                result = evaluate(rValue, in);</span><br><span class="line">                <span class="keyword">if</span> (canHoldInt(def)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> out.update(def, result) || isChange;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> isChange;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.copyFrom(in);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h3><p><font color=blue><strong>Tips ：</strong> </font></p>
<ol>
<li>此处的值是格上的抽象值。</li>
<li><code>transferNode()</code> 方法中调用它来进行表达式的求值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Value <span class="title function_">evaluate</span><span class="params">(Exp exp, CPFact in)</span> &#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">tmpValue</span> <span class="operator">=</span> Value.getNAC();</span><br><span class="line">        <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> IntLiteral) &#123;<span class="comment">//Constant</span></span><br><span class="line">            <span class="type">IntLiteral</span> <span class="variable">intLiteral</span> <span class="operator">=</span> (IntLiteral) exp;</span><br><span class="line">            <span class="keyword">return</span> Value.makeConstant(intLiteral.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> Var) &#123;<span class="comment">//Constant</span></span><br><span class="line">            <span class="type">Var</span> <span class="variable">use</span> <span class="operator">=</span> (Var) exp;</span><br><span class="line">            <span class="type">Value</span> <span class="variable">useInt</span> <span class="operator">=</span> in.get(use);</span><br><span class="line">            <span class="keyword">if</span>(canHoldInt(use)) &#123;</span><br><span class="line">                <span class="keyword">return</span> useInt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> BinaryExp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ArithmeticExp) &#123;<span class="comment">// ArithmeticExp</span></span><br><span class="line">                <span class="comment">//Solution</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ConditionExp) &#123;<span class="comment">// ConditionExp</span></span><br><span class="line">                <span class="comment">//Solution</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ShiftExp) &#123;<span class="comment">// ShiftExp</span></span><br><span class="line">                <span class="comment">//Solution</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> BitwiseExp) &#123;<span class="comment">// BitwiseExp</span></span><br><span class="line">                <span class="comment">//Solution</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Worklist求解器"><a href="#实现Worklist求解器" class="headerlink" title="实现Worklist求解器"></a>实现Worklist求解器</h2><h3 id="initializeForward"><a href="#initializeForward" class="headerlink" title="initializeForward"></a>initializeForward</h3><p><font color=blue><strong>Tips ：</strong> </font>对算法前三行进行实现，要将IN初始化与OUT一样，因为meetInto函数是逐个将OUT合并进入IN</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeForward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// OUT[stmt] = null, IN[stmt] = null</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">entry</span> <span class="operator">=</span> cfg.getEntry();</span><br><span class="line">        <span class="type">Fact</span> <span class="variable">entryInFact</span> <span class="operator">=</span> analysis.newBoundaryFact(cfg);</span><br><span class="line">        <span class="type">Fact</span> <span class="variable">entryOutFact</span> <span class="operator">=</span> analysis.newBoundaryFact(cfg);</span><br><span class="line">        result.setInFact(entry, entryInFact);</span><br><span class="line">        result.setOutFact(entry, entryOutFact);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node stmt : cfg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cfg.isEntry(stmt)) &#123;</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">stmtInFact</span> <span class="operator">=</span> analysis.newInitialFact();</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">stmtOutFact</span> <span class="operator">=</span> analysis.newInitialFact();</span><br><span class="line">                result.setOutFact(stmt, stmtOutFact);</span><br><span class="line">                result.setInFact(stmt, stmtInFact);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="doSolveBackward"><a href="#doSolveBackward" class="headerlink" title="doSolveBackward"></a>doSolveBackward</h3><p><font color=blue><strong>Tips ：</strong> </font>使用<code>LinkedList</code>来实现worklist</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveForward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// WorkList while loop</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node stmt : cfg) &#123;</span><br><span class="line">            queue.add(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmpStmt</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (!cfg.isEntry(tmpStmt)) &#123;</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">oriOut</span> <span class="operator">=</span> result.getOutFact(tmpStmt);</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">oriIn</span> <span class="operator">=</span> result.getInFact(tmpStmt);</span><br><span class="line">                <span class="keyword">for</span> (Node pre : cfg.getPredsOf(tmpStmt)) &#123;</span><br><span class="line">                    <span class="type">Fact</span> <span class="variable">outPre</span> <span class="operator">=</span> result.getOutFact(pre);</span><br><span class="line">                    analysis.meetInto(outPre, oriIn);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isChange</span> <span class="operator">=</span> analysis.transferNode(tmpStmt, oriIn, oriOut);</span><br><span class="line">                <span class="keyword">if</span> (isChange) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node suc : cfg.getSuccsOf(tmpStmt)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!queue.contains(suc)) &#123;</span><br><span class="line">                            queue.add(suc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tai-e assignment</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Static Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Tai-e-A3</title>
    <url>/2023/07/12/Tai-e-A3/</url>
    <content><![CDATA[<h1 id="死代码检测"><a href="#死代码检测" class="headerlink" title="死代码检测"></a>死代码检测</h1><h2 id="感叹一下"><a href="#感叹一下" class="headerlink" title="感叹一下"></a>感叹一下</h2><p>又是花了一个大夜来debug 有一个corner case错误。</p>
<p><strong>原因！</strong>接口问题！如果是<code>switchStmt</code>中，表达式值不是<code>constant</code>，此时应该把所有后继全部加入，而不是<code>getTarget()</code>，它这里应该是忽略了<code>defaultTarget</code>，所以导致deadcode多加了四个case</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Stmt&gt; sucSet = cfg.getSuccsOf(switchStmt);</span><br><span class="line">                    <span class="keyword">for</span>(Stmt suc : sucSet) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!liveCode.contains(suc)) &#123;</span><br><span class="line">                            que.add(suc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// List&lt;Stmt&gt; listStmt = switchStmt.getTargets();</span></span><br><span class="line">                    <span class="comment">// for(Stmt stmt : listStmt) &#123;</span></span><br><span class="line">                    <span class="comment">//     if(!liveCode.contains(stmt)) &#123;</span></span><br><span class="line">                    <span class="comment">//         que.add(stmt);</span></span><br><span class="line">                    <span class="comment">//     &#125;</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="不可达代码"><a href="#不可达代码" class="headerlink" title="不可达代码"></a>不可达代码</h2><p><em><strong>控制流不可达代码</strong></em>： 在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。比如，由于返回语句是一个方法的出口，所以跟在它后面的代码是不可达的。</p>
<p><strong>检测方式</strong>：这样的代码可以很简单地利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是控制流不可达的。</p>
<p><em><strong>分支不可达代码</strong></em>. 在 Java 中有两种分支语句：<em>if</em> 语句和 <em>switch</em> 语句。它们可能会导致分支不可达代码的出现。</p>
<p>对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为<strong>不可达分支</strong>。</p>
<p><strong>检测方式</strong>：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。</p>
<h2 id="无用赋值"><a href="#无用赋值" class="headerlink" title="无用赋值"></a>无用赋值</h2><p>一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为<strong>无用变量</strong>（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。如下面的代码片段所示，第 3 行和第 5 行的语句都是无用赋值。</p>
<p><strong>检测方式</strong>：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。</p>
<p><strong>Tips:</strong> fallThrough语句会被正常的case流入然后处理，并不需要特殊处理，这里可以方便简化，所以我的fallThrough判定都是冗余的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Stmt&gt; <span class="title function_">analyze</span><span class="params">(IR ir)</span> &#123;</span><br><span class="line">        <span class="comment">// obtain CFG</span></span><br><span class="line">        CFG&lt;Stmt&gt; cfg = ir.getResult(CFGBuilder.ID);</span><br><span class="line">        <span class="comment">// obtain result of constant propagation</span></span><br><span class="line">        DataflowResult&lt;Stmt, CPFact&gt; constants =</span><br><span class="line">                ir.getResult(ConstantPropagation.ID);</span><br><span class="line">        <span class="comment">// obtain result of live variable analysis</span></span><br><span class="line">        DataflowResult&lt;Stmt, SetFact&lt;Var&gt;&gt; liveVars =</span><br><span class="line">                ir.getResult(LiveVariableAnalysis.ID);</span><br><span class="line">        <span class="comment">// keep statements (dead code) sorted in the resulting set</span></span><br><span class="line">        Set&lt;Stmt&gt; deadCode = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));</span><br><span class="line">        <span class="comment">// keep statements (live code)</span></span><br><span class="line">        Set&lt;Stmt&gt; liveCode = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));</span><br><span class="line">        <span class="comment">// use to BFS of cfg</span></span><br><span class="line">        Queue&lt;Stmt&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        que.add(cfg.getEntry());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Stmt</span> <span class="variable">tmpStmt</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="comment">// check type of the stmt</span></span><br><span class="line">            <span class="keyword">if</span>(tmpStmt <span class="keyword">instanceof</span> AssignStmt&lt;?,?&gt; assignStmt) &#123;</span><br><span class="line">                <span class="type">LValue</span> <span class="variable">lValue</span> <span class="operator">=</span> assignStmt.getLValue();</span><br><span class="line">                <span class="type">RValue</span> <span class="variable">rValue</span> <span class="operator">=</span> assignStmt.getRValue();</span><br><span class="line">                <span class="keyword">if</span>(hasNoSideEffect(rValue)) &#123;<span class="comment">// no side effect</span></span><br><span class="line">                    SetFact&lt;Var&gt; liveVarOfStmt = liveVars.getOutFact(assignStmt);</span><br><span class="line">                    <span class="keyword">if</span>(lValue <span class="keyword">instanceof</span> Var <span class="keyword">var</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!liveVarOfStmt.contains(<span class="keyword">var</span>)) &#123;</span><br><span class="line">                            deadCode.add(tmpStmt);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            liveCode.add(tmpStmt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        liveCode.add(tmpStmt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">// side effect</span></span><br><span class="line">                    liveCode.add(tmpStmt);</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;Stmt&gt; sucSet = cfg.getSuccsOf(tmpStmt);</span><br><span class="line">                <span class="keyword">for</span>(Stmt suc : sucSet) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!liveCode.contains(suc)) &#123;</span><br><span class="line">                        que.add(suc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmpStmt <span class="keyword">instanceof</span> If ifStmt) &#123;</span><br><span class="line">                <span class="type">ConditionExp</span> <span class="variable">conditionExp</span> <span class="operator">=</span> ifStmt.getCondition();</span><br><span class="line">                <span class="type">Value</span> <span class="variable">value</span> <span class="operator">=</span> ConstantPropagation.evaluate(conditionExp, constants.getInFact(ifStmt));</span><br><span class="line">                <span class="keyword">if</span>(!value.isConstant()) &#123;</span><br><span class="line">                    Set&lt;Stmt&gt; stmts = cfg.getSuccsOf(tmpStmt);</span><br><span class="line">                    liveCode.add(tmpStmt);</span><br><span class="line">                    <span class="keyword">for</span>(Stmt stmt : stmts) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!liveCode.contains(stmt)) &#123;</span><br><span class="line">                            que.add(stmt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Set&lt;Edge&lt;Stmt&gt;&gt; edges = cfg.getOutEdgesOf(tmpStmt);</span><br><span class="line">                    liveCode.add(tmpStmt);</span><br><span class="line">                    <span class="keyword">for</span>(Edge&lt;Stmt&gt; edge : edges) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(edge.getKind() == Edge.Kind.IF_FALSE) &#123; <span class="comment">//IF_FALSE</span></span><br><span class="line">                            <span class="keyword">if</span>(value.getConstant() == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="type">Stmt</span> <span class="variable">falseStmt</span> <span class="operator">=</span> edge.getTarget();</span><br><span class="line">                                <span class="keyword">if</span>(!liveCode.contains(falseStmt) &amp;&amp; !que.contains(falseStmt)) &#123;</span><br><span class="line">                                    que.add(falseStmt);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="type">Stmt</span> <span class="variable">trueStmt</span> <span class="operator">=</span> edge.getTarget();</span><br><span class="line">                                deadCode.add(trueStmt);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (edge.getKind() == Edge.Kind.IF_TRUE) &#123; <span class="comment">//IF_TRUE</span></span><br><span class="line">                            <span class="keyword">if</span>(value.getConstant() == <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="type">Stmt</span> <span class="variable">trueStmt</span> <span class="operator">=</span> edge.getTarget();</span><br><span class="line">                                <span class="keyword">if</span>(!liveCode.contains(trueStmt) &amp;&amp; !que.contains(trueStmt)) &#123;</span><br><span class="line">                                    que.add(trueStmt);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="type">Stmt</span> <span class="variable">trueStmt</span> <span class="operator">=</span> edge.getTarget();</span><br><span class="line">                                deadCode.add(trueStmt);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmpStmt <span class="keyword">instanceof</span> SwitchStmt switchStmt) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> switchStmt.getVar();</span><br><span class="line">                <span class="type">Value</span> <span class="variable">value</span> <span class="operator">=</span> ConstantPropagation.evaluate(<span class="keyword">var</span>, constants.getInFact(tmpStmt));</span><br><span class="line">                liveCode.add(tmpStmt);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!value.isConstant()) &#123;</span><br><span class="line">                    Set&lt;Stmt&gt; sucSet = cfg.getSuccsOf(switchStmt);</span><br><span class="line">                    <span class="keyword">for</span>(Stmt suc : sucSet) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!liveCode.contains(suc)) &#123;</span><br><span class="line">                            que.add(suc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> value.getConstant();</span><br><span class="line">                    List&lt;Integer&gt; listInteger = switchStmt.getCaseValues();</span><br><span class="line">                    List&lt;Pair&lt;Integer, Stmt&gt;&gt; listStmt = switchStmt.getCaseTargets();</span><br><span class="line">                    <span class="keyword">if</span>(listInteger.contains(ans)) &#123;</span><br><span class="line">                        Set&lt;Edge&lt;Stmt&gt;&gt; edges = cfg.getOutEdgesOf(switchStmt);</span><br><span class="line">                        <span class="keyword">for</span>(Edge&lt;Stmt&gt; edge : edges) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(edge.getKind() == Edge.Kind.SWITCH_CASE) &#123;</span><br><span class="line">                                <span class="keyword">if</span>(edge.getCaseValue() == ans) &#123;</span><br><span class="line">                                    <span class="keyword">if</span>(!liveCode.contains(edge.getTarget()) &amp;&amp; !que.contains(edge.getTarget())) &#123;</span><br><span class="line">                                        que.add(edge.getTarget());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                                    if(switchStmt.canFallThrough()) &#123;</span></span><br><span class="line"><span class="comment">//                                        Set&lt;Edge&lt;Stmt&gt;&gt; inEdges = cfg.getInEdgesOf(edge.getTarget());</span></span><br><span class="line"><span class="comment">//                                        for(Edge&lt;Stmt&gt; inEdge : inEdges) &#123;</span></span><br><span class="line"><span class="comment">//                                            if(inEdge.getKind() == Edge.Kind.FALL_THROUGH) &#123;</span></span><br><span class="line"><span class="comment">//                                                for(int i = 0; i &lt; listInteger.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//                                                    if(inEdge.getTarget() == switchStmt.getTarget(i))&#123;</span></span><br><span class="line"><span class="comment">//                                                        if(que.contains(switchStmt.getTarget(i - 1))) &#123;</span></span><br><span class="line"><span class="comment">//                                                            if(!liveCode.contains(inEdge.getTarget()) &amp;&amp; !que.contains(inEdge.getTarget())) &#123;</span></span><br><span class="line"><span class="comment">//                                                                que.add(inEdge.getTarget());</span></span><br><span class="line"><span class="comment">//                                                            &#125;</span></span><br><span class="line"><span class="comment">//                                                        &#125;</span></span><br><span class="line"><span class="comment">//                                                    &#125;</span></span><br><span class="line"><span class="comment">//                                                &#125;</span></span><br><span class="line"><span class="comment">//                                            &#125;</span></span><br><span class="line"><span class="comment">//                                        &#125;</span></span><br><span class="line"><span class="comment">//                                    &#125;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.getKind() == Edge.Kind.SWITCH_DEFAULT) &#123;</span><br><span class="line"><span class="comment">//                                if(switchStmt.canFallThrough()) &#123;</span></span><br><span class="line"><span class="comment">//                                    Set&lt;Edge&lt;Stmt&gt;&gt; inEdges = cfg.getInEdgesOf(edge.getTarget());</span></span><br><span class="line"><span class="comment">//                                    for(Edge&lt;Stmt&gt; inEdge : inEdges) &#123;</span></span><br><span class="line"><span class="comment">//                                        if(inEdge.getKind() == Edge.Kind.FALL_THROUGH) &#123;</span></span><br><span class="line"><span class="comment">//                                            for(int i = 0; i &lt; listInteger.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//                                                if(inEdge.getTarget() == switchStmt.getTarget(i))&#123;</span></span><br><span class="line"><span class="comment">//                                                    if(que.contains(switchStmt.getTarget(i - 1))) &#123;</span></span><br><span class="line"><span class="comment">//                                                        if(!liveCode.contains(inEdge.getTarget()) &amp;&amp; !que.contains(inEdge.getTarget())) &#123;</span></span><br><span class="line"><span class="comment">//                                                            que.add(inEdge.getTarget());</span></span><br><span class="line"><span class="comment">//                                                        &#125;</span></span><br><span class="line"><span class="comment">//                                                    &#125;</span></span><br><span class="line"><span class="comment">//                                                &#125;</span></span><br><span class="line"><span class="comment">//                                            &#125;</span></span><br><span class="line"><span class="comment">//                                        &#125;</span></span><br><span class="line"><span class="comment">//                                    &#125;</span></span><br><span class="line"><span class="comment">//                                &#125;</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span>(!liveCode.contains(edge.getTarget()) &amp;&amp; !que.contains(edge.getTarget())) &#123;</span><br><span class="line">                                    que.add(edge.getTarget());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span>(Pair&lt;Integer, Stmt&gt; pair: listStmt) &#123;</span><br><span class="line">                            deadCode.add(pair.second());</span><br><span class="line">                        &#125;</span><br><span class="line">                        que.add(switchStmt.getDefaultTarget());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                liveCode.add(tmpStmt);</span><br><span class="line">                Set&lt;Stmt&gt; sucSet = cfg.getSuccsOf(tmpStmt);</span><br><span class="line">                <span class="keyword">for</span>(Stmt suc : sucSet) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!liveCode.contains(suc)) &#123;</span><br><span class="line">                        que.add(suc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Stmt stmt : cfg.getIR().getStmts()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!liveCode.contains(stmt) &amp;&amp; !deadCode.contains(stmt)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!cfg.isExit(stmt)) &#123;</span><br><span class="line">                    deadCode.add(stmt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deadCode.isEmpty() ? Collections.emptySet() : deadCode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tai-e assignment</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Static Analysis</tag>
      </tags>
  </entry>
</search>
